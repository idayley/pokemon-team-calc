<?xml version="1.0" encoding="UTF-8"?>
<jsx_files>

  <file_entry>
    <file_path>node_modules\react-beautiful-dnd\src\view\animate-in-out\animate-in-out.jsx</file_path>
    <file_name>animate-in-out.jsx</file_name>
    <content>
    <![CDATA[
// @flow
import React, { type Node } from 'react';
import type { InOutAnimationMode } from '../../types';

export type AnimateProvided = {|
  onClose: () => void,
  animate: InOutAnimationMode,
  data: mixed,
|};

type Props = {|
  on: mixed,
  shouldAnimate: boolean,
  children: (provided: AnimateProvided) => Node,
|};

type State = {|
  data: mixed,
  isVisible: boolean,
  animate: InOutAnimationMode,
|};

// Using a class here rather than hooks because
// getDerivedStateFromProps results in far less renders.
// Using hooks to implement this was quite messy and resulted in lots of additional renders

export default class AnimateInOut extends React.PureComponent<Props, State> {
  state: State = {
    isVisible: Boolean(this.props.on),
    data: this.props.on,
    // not allowing to animate close on mount
    animate: this.props.shouldAnimate && this.props.on ? 'open' : 'none',
  };

  static getDerivedStateFromProps(props: Props, state: State): State {
    if (!props.shouldAnimate) {
      return {
        isVisible: Boolean(props.on),
        data: props.on,
        animate: 'none',
      };
    }

    // need to animate in
    if (props.on) {
      return {
        isVisible: true,
        // have new data to animate in with
        data: props.on,
        animate: 'open',
      };
    }

    // need to animate out if there was data

    if (state.isVisible) {
      return {
        isVisible: true,
        // use old data for animating out
        data: state.data,
        animate: 'close',
      };
    }

    // close animation no longer visible
    return {
      isVisible: false,
      animate: 'close',
      data: null,
    };
  }

  onClose = () => {
    if (this.state.animate !== 'close') {
      return;
    }

    this.setState({
      isVisible: false,
    });
  };

  render() {
    if (!this.state.isVisible) {
      return null;
    }

    const provided: AnimateProvided = {
      onClose: this.onClose,
      data: this.state.data,
      animate: this.state.animate,
    };
    return this.props.children(provided);
  }
}

    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>node_modules\react-beautiful-dnd\src\view\drag-drop-context\app.jsx</file_path>
    <file_name>app.jsx</file_name>
    <content>
    <![CDATA[
// @flow
import React, { useEffect, useRef, type Node } from 'react';
import { bindActionCreators } from 'redux';
import { Provider } from 'react-redux';
import { useMemo, useCallback } from 'use-memo-one';
import { invariant } from '../../invariant';
import createStore from '../../state/create-store';
import createDimensionMarshal from '../../state/dimension-marshal/dimension-marshal';
import canStartDrag from '../../state/can-start-drag';
import scrollWindow from '../window/scroll-window';
import createAutoScroller from '../../state/auto-scroller';
import useStyleMarshal from '../use-style-marshal/use-style-marshal';
import useFocusMarshal from '../use-focus-marshal';
import useRegistry from '../../state/registry/use-registry';
import type { Registry } from '../../state/registry/registry-types';
import type { FocusMarshal } from '../use-focus-marshal/focus-marshal-types';
import type { AutoScroller } from '../../state/auto-scroller/auto-scroller-types';
import type { StyleMarshal } from '../use-style-marshal/style-marshal-types';
import type {
  DimensionMarshal,
  Callbacks as DimensionMarshalCallbacks,
} from '../../state/dimension-marshal/dimension-marshal-types';
import type {
  DraggableId,
  State,
  Responders,
  Announce,
  Sensor,
  ElementId,
} from '../../types';
import type { Store, Action } from '../../state/store-types';
import type { SetAppCallbacks, AppCallbacks } from './drag-drop-context-types';
import StoreContext from '../context/store-context';
import {
  move,
  publishWhileDragging,
  updateDroppableScroll,
  updateDroppableIsEnabled,
  updateDroppableIsCombineEnabled,
  collectionStarting,
  flush,
} from '../../state/action-creators';
import isMovementAllowed from '../../state/is-movement-allowed';
import useAnnouncer from '../use-announcer';
import useHiddenTextElement from '../use-hidden-text-element';
import AppContext, { type AppContextValue } from '../context/app-context';
import useStartupValidation from './use-startup-validation';
import usePrevious from '../use-previous-ref';
import { warning } from '../../dev-warning';
import useSensorMarshal from '../use-sensor-marshal/use-sensor-marshal';

export type Props = {|
  ...Responders,
  contextId: string,
  setCallbacks: SetAppCallbacks,
  nonce?: string,
  // we do not technically need any children for this component
  children: Node | null,

  // sensors
  sensors?: Sensor[],
  enableDefaultSensors?: ?boolean,

  // screen reader
  dragHandleUsageInstructions: string,
|};

const createResponders = (props: Props): Responders => ({
  onBeforeCapture: props.onBeforeCapture,
  onBeforeDragStart: props.onBeforeDragStart,
  onDragStart: props.onDragStart,
  onDragEnd: props.onDragEnd,
  onDragUpdate: props.onDragUpdate,
});

// flow does not support MutableRefObject
// type LazyStoreRef = MutableRefObject<?Store>;
type LazyStoreRef = {| current: ?Store |};

function getStore(lazyRef: LazyStoreRef): Store {
  invariant(lazyRef.current, 'Could not find store from lazy ref');
  return lazyRef.current;
}

export default function App(props: Props) {
  const {
    contextId,
    setCallbacks,
    sensors,
    nonce,
    dragHandleUsageInstructions,
  } = props;
  const lazyStoreRef: LazyStoreRef = useRef<?Store>(null);

  useStartupValidation();

  // lazy collection of responders using a ref - update on ever render
  const lastPropsRef = usePrevious<Props>(props);

  const getResponders: () => Responders = useCallback(() => {
    return createResponders(lastPropsRef.current);
  }, [lastPropsRef]);

  const announce: Announce = useAnnouncer(contextId);

  const dragHandleUsageInstructionsId: ElementId = useHiddenTextElement({
    contextId,
    text: dragHandleUsageInstructions,
  });
  const styleMarshal: StyleMarshal = useStyleMarshal(contextId, nonce);

  const lazyDispatch: (Action) => void = useCallback((action: Action): void => {
    getStore(lazyStoreRef).dispatch(action);
  }, []);

  const marshalCallbacks: DimensionMarshalCallbacks = useMemo(
    () =>
      bindActionCreators(
        {
          publishWhileDragging,
          updateDroppableScroll,
          updateDroppableIsEnabled,
          updateDroppableIsCombineEnabled,
          collectionStarting,
        },
        // $FlowFixMe - not sure why this is wrong
        lazyDispatch,
      ),
    [lazyDispatch],
  );

  const registry: Registry = useRegistry();

  const dimensionMarshal: DimensionMarshal = useMemo<DimensionMarshal>(() => {
    return createDimensionMarshal(registry, marshalCallbacks);
  }, [registry, marshalCallbacks]);

  const autoScroller: AutoScroller = useMemo<AutoScroller>(
    () =>
      createAutoScroller({
        scrollWindow,
        scrollDroppable: dimensionMarshal.scrollDroppable,
        ...bindActionCreators(
          {
            move,
          },
          // $FlowFixMe - not sure why this is wrong
          lazyDispatch,
        ),
      }),
    [dimensionMarshal.scrollDroppable, lazyDispatch],
  );

  const focusMarshal: FocusMarshal = useFocusMarshal(contextId);

  const store: Store = useMemo<Store>(
    () =>
      createStore({
        announce,
        autoScroller,
        dimensionMarshal,
        focusMarshal,
        getResponders,
        styleMarshal,
      }),
    [
      announce,
      autoScroller,
      dimensionMarshal,
      focusMarshal,
      getResponders,
      styleMarshal,
    ],
  );

  // Checking for unexpected store changes
  if (process.env.NODE_ENV !== 'production') {
    if (lazyStoreRef.current && lazyStoreRef.current !== store) {
      warning('unexpected store change');
    }
  }

  // assigning lazy store ref
  lazyStoreRef.current = store;

  const tryResetStore = useCallback(() => {
    const current: Store = getStore(lazyStoreRef);
    const state: State = current.getState();
    if (state.phase !== 'IDLE') {
      current.dispatch(flush());
    }
  }, []);

  const isDragging = useCallback((): boolean => {
    const state: State = getStore(lazyStoreRef).getState();
    return state.isDragging || state.phase === 'DROP_ANIMATING';
  }, []);

  const appCallbacks: AppCallbacks = useMemo(
    () => ({
      isDragging,
      tryAbort: tryResetStore,
    }),
    [isDragging, tryResetStore],
  );

  // doing this in render rather than a side effect so any errors on the
  // initial mount are caught
  setCallbacks(appCallbacks);

  const getCanLift = useCallback(
    (id: DraggableId) => canStartDrag(getStore(lazyStoreRef).getState(), id),
    [],
  );

  const getIsMovementAllowed = useCallback(
    () => isMovementAllowed(getStore(lazyStoreRef).getState()),
    [],
  );

  const appContext: AppContextValue = useMemo(
    () => ({
      marshal: dimensionMarshal,
      focus: focusMarshal,
      contextId,
      canLift: getCanLift,
      isMovementAllowed: getIsMovementAllowed,
      dragHandleUsageInstructionsId,
      registry,
    }),
    [
      contextId,
      dimensionMarshal,
      dragHandleUsageInstructionsId,
      focusMarshal,
      getCanLift,
      getIsMovementAllowed,
      registry,
    ],
  );

  useSensorMarshal({
    contextId,
    store,
    registry,
    customSensors: sensors,
    // default to 'true' unless 'false' is explicitly passed
    enableDefaultSensors: props.enableDefaultSensors !== false,
  });

  // Clean store when unmounting
  useEffect(() => {
    return tryResetStore;
  }, [tryResetStore]);

  return (
    <AppContext.Provider value={appContext}>
      <Provider context={StoreContext} store={store}>
        {props.children}
      </Provider>
    </AppContext.Provider>
  );
}

    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>node_modules\react-beautiful-dnd\src\view\drag-drop-context\drag-drop-context.jsx</file_path>
    <file_name>drag-drop-context.jsx</file_name>
    <content>
    <![CDATA[
// @flow
import React, { type Node } from 'react';
import type { Responders, ContextId, Sensor } from '../../types';
import ErrorBoundary from './error-boundary';
import preset from '../../screen-reader-message-preset';
import App from './app';
import useUniqueContextId, {
  reset as resetContextId,
} from './use-unique-context-id';
import { reset as resetUniqueIds } from '../use-unique-id';

type Props = {|
  ...Responders,
  // We do not technically need any children for this component
  children: Node | null,
  // Read out by screen readers when focusing on a drag handle
  dragHandleUsageInstructions?: string,
  // Used for strict content security policies
  // See our [content security policy guide](/docs/guides/content-security-policy.md)
  nonce?: string,
  // See our [sensor api](/docs/sensors/sensor-api.md)
  sensors?: Sensor[],
  enableDefaultSensors?: ?boolean,
|};

// Reset any context that gets persisted across server side renders
export function resetServerContext() {
  resetContextId();
  resetUniqueIds();
}

export default function DragDropContext(props: Props) {
  const contextId: ContextId = useUniqueContextId();
  const dragHandleUsageInstructions: string =
    props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;

  // We need the error boundary to be on the outside of App
  // so that it can catch any errors caused by App
  return (
    <ErrorBoundary>
      {(setCallbacks) => (
        <App
          nonce={props.nonce}
          contextId={contextId}
          setCallbacks={setCallbacks}
          dragHandleUsageInstructions={dragHandleUsageInstructions}
          enableDefaultSensors={props.enableDefaultSensors}
          sensors={props.sensors}
          onBeforeCapture={props.onBeforeCapture}
          onBeforeDragStart={props.onBeforeDragStart}
          onDragStart={props.onDragStart}
          onDragUpdate={props.onDragUpdate}
          onDragEnd={props.onDragEnd}
        >
          {props.children}
        </App>
      )}
    </ErrorBoundary>
  );
}

    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>node_modules\react-beautiful-dnd\src\view\drag-drop-context\error-boundary.jsx</file_path>
    <file_name>error-boundary.jsx</file_name>
    <content>
    <![CDATA[
// @flow
import React, { type Node } from 'react';
import { warning, error } from '../../dev-warning';
import { noop } from '../../empty';
import bindEvents from '../event-bindings/bind-events';
import { RbdInvariant } from '../../invariant';
import type { AppCallbacks } from './drag-drop-context-types';

type Props = {|
  children: (setCallbacks: (callbacks: AppCallbacks) => void) => Node,
|};

// Lame that this is not in flow
type ErrorEvent = Event & {
  error: ?Error,
};

export default class ErrorBoundary extends React.Component<Props> {
  callbacks: ?AppCallbacks = null;
  unbind: () => void = noop;

  componentDidMount() {
    this.unbind = bindEvents(window, [
      {
        eventName: 'error',
        fn: this.onWindowError,
      },
    ]);
  }

  componentDidCatch(err: Error) {
    if (err instanceof RbdInvariant) {
      if (process.env.NODE_ENV !== 'production') {
        error(err.message);
      }

      this.setState({});
      return;
    }

    // throwing error for other error boundaries
    // eslint-disable-next-line no-restricted-syntax
    throw err;
  }

  componentWillUnmount() {
    this.unbind();
  }

  onWindowError = (event: ErrorEvent) => {
    const callbacks: AppCallbacks = this.getCallbacks();

    if (callbacks.isDragging()) {
      callbacks.tryAbort();
      warning(`
        An error was caught by our window 'error' event listener while a drag was occurring.
        The active drag has been aborted.
      `);
    }

    const err: ?Error = event.error;

    if (err instanceof RbdInvariant) {
      // Marking the event as dealt with.
      // This will prevent any 'uncaught' error warnings in the console
      event.preventDefault();
      if (process.env.NODE_ENV !== 'production') {
        error(err.message);
      }
    }
  };

  getCallbacks = (): AppCallbacks => {
    if (!this.callbacks) {
      // eslint-disable-next-line no-restricted-syntax
      throw new Error('Unable to find AppCallbacks in <ErrorBoundary/>');
    }
    return this.callbacks;
  };

  setCallbacks = (callbacks: AppCallbacks) => {
    this.callbacks = callbacks;
  };

  render() {
    return this.props.children(this.setCallbacks);
  }
}

    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>node_modules\react-beautiful-dnd\src\view\draggable\draggable-api.jsx</file_path>
    <file_name>draggable-api.jsx</file_name>
    <content>
    <![CDATA[
// @flow
import React from 'react';
import type { DraggableId } from '../../types';
import type { PublicOwnProps, PrivateOwnProps } from './draggable-types';
import ConnectedDraggable from './connected-draggable';
import useRequiredContext from '../use-required-context';
import DroppableContext, {
  type DroppableContextValue,
} from '../context/droppable-context';

// We can use this to render a draggable with more control
// It is used by a Droppable to render a clone
export function PrivateDraggable(props: PrivateOwnProps) {
  const droppableContext: DroppableContextValue = useRequiredContext(
    DroppableContext,
  );
  // The droppable can render a clone of the draggable item.
  // In that case we unmount the existing dragging item
  const isUsingCloneFor: ?DraggableId = droppableContext.isUsingCloneFor;
  if (isUsingCloneFor === props.draggableId && !props.isClone) {
    return null;
  }

  return <ConnectedDraggable {...props} />;
}

// What we give to consumers
export function PublicDraggable(props: PublicOwnProps) {
  // default values for props
  const isEnabled: boolean =
    typeof props.isDragDisabled === 'boolean' ? !props.isDragDisabled : true;
  const canDragInteractiveElements: boolean = Boolean(
    props.disableInteractiveElementBlocking,
  );
  const shouldRespectForcePress: boolean = Boolean(
    props.shouldRespectForcePress,
  );

  return (
    <PrivateDraggable
      {...props}
      isClone={false}
      isEnabled={isEnabled}
      canDragInteractiveElements={canDragInteractiveElements}
      shouldRespectForcePress={shouldRespectForcePress}
    />
  );
}

    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>node_modules\react-beautiful-dnd\src\view\draggable\draggable.jsx</file_path>
    <file_name>draggable.jsx</file_name>
    <content>
    <![CDATA[
// @flow
import { useRef } from 'react';
import { useMemo, useCallback } from 'use-memo-one';
import type { DraggableRubric, DraggableDescriptor } from '../../types';
import getStyle from './get-style';
import useDraggablePublisher, {
  type Args as PublisherArgs,
} from '../use-draggable-publisher/use-draggable-publisher';
import AppContext from '../context/app-context';
import DroppableContext from '../context/droppable-context';
import type {
  Props,
  Provided,
  DraggableStyle,
  DragHandleProps,
} from './draggable-types';
import { useValidation, useClonePropValidation } from './use-validation';
import useRequiredContext from '../use-required-context';

function preventHtml5Dnd(event: DragEvent) {
  event.preventDefault();
}

export default function Draggable(props: Props) {
  // reference to DOM node
  const ref = useRef<?HTMLElement>(null);
  const setRef = useCallback((el: ?HTMLElement) => {
    ref.current = el;
  }, []);
  const getRef = useCallback((): ?HTMLElement => ref.current, []);

  // context
  const {
    contextId,
    dragHandleUsageInstructionsId,
    registry,
  } = useRequiredContext(AppContext);
  const { type, droppableId } = useRequiredContext(DroppableContext);

  const descriptor: DraggableDescriptor = useMemo(
    () => ({
      id: props.draggableId,
      index: props.index,
      type,
      droppableId,
    }),
    [props.draggableId, props.index, type, droppableId],
  );

  // props
  const {
    // ownProps
    children,
    draggableId,
    isEnabled,
    shouldRespectForcePress,
    canDragInteractiveElements,
    isClone,

    // mapProps
    mapped,

    // dispatchProps
    dropAnimationFinished: dropAnimationFinishedAction,
  } = props;

  // Validating props and innerRef
  useValidation(props, contextId, getRef);

  // Clones do not speak to the dimension marshal
  // We are violating the rules of hooks here: conditional hooks.
  // In this specific use case it is okay as an item will always either be a
  // clone or not for it's whole lifecycle
  /* eslint-disable react-hooks/rules-of-hooks */

  // Being super sure that isClone is not changing during a draggable lifecycle
  useClonePropValidation(isClone);
  if (!isClone) {
    const forPublisher: PublisherArgs = useMemo(
      () => ({
        descriptor,
        registry,
        getDraggableRef: getRef,
        canDragInteractiveElements,
        shouldRespectForcePress,
        isEnabled,
      }),
      [
        descriptor,
        registry,
        getRef,
        canDragInteractiveElements,
        shouldRespectForcePress,
        isEnabled,
      ],
    );
    useDraggablePublisher(forPublisher);
  }
  /* eslint-enable react-hooks/rules-of-hooks */

  const dragHandleProps: ?DragHandleProps = useMemo(
    () =>
      isEnabled
        ? {
            // See `draggable-types` for an explanation of why these are used
            tabIndex: 0,
            role: 'button',
            'aria-describedby': dragHandleUsageInstructionsId,
            'data-rbd-drag-handle-draggable-id': draggableId,
            'data-rbd-drag-handle-context-id': contextId,
            draggable: false,
            onDragStart: preventHtml5Dnd,
          }
        : null,
    [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled],
  );

  const onMoveEnd = useCallback(
    (event: TransitionEvent) => {
      if (mapped.type !== 'DRAGGING') {
        return;
      }

      if (!mapped.dropping) {
        return;
      }

      // There might be other properties on the element that are
      // being transitioned. We do not want those to end a drop animation!
      if (event.propertyName !== 'transform') {
        return;
      }

      dropAnimationFinishedAction();
    },
    [dropAnimationFinishedAction, mapped],
  );

  const provided: Provided = useMemo(() => {
    const style: DraggableStyle = getStyle(mapped);
    const onTransitionEnd =
      mapped.type === 'DRAGGING' && mapped.dropping ? onMoveEnd : null;

    const result: Provided = {
      innerRef: setRef,
      draggableProps: {
        'data-rbd-draggable-context-id': contextId,
        'data-rbd-draggable-id': draggableId,
        style,
        onTransitionEnd,
      },
      dragHandleProps,
    };

    return result;
  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef]);

  const rubric: DraggableRubric = useMemo(
    () => ({
      draggableId: descriptor.id,
      type: descriptor.type,
      source: {
        index: descriptor.index,
        droppableId: descriptor.droppableId,
      },
    }),
    [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type],
  );

  return children(provided, mapped.snapshot, rubric);
}

    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>node_modules\react-beautiful-dnd\src\view\droppable\droppable.jsx</file_path>
    <file_name>droppable.jsx</file_name>
    <content>
    <![CDATA[
// @flow
import ReactDOM from 'react-dom';
import { useMemo, useCallback } from 'use-memo-one';
import React, { useRef, useContext, type Node } from 'react';
import { invariant } from '../../invariant';
import type { DraggableId } from '../../types';
import type { Props, Provided } from './droppable-types';
import useDroppablePublisher from '../use-droppable-publisher';
import Placeholder from '../placeholder';
import AppContext, { type AppContextValue } from '../context/app-context';
import DroppableContext, {
  type DroppableContextValue,
} from '../context/droppable-context';
// import useAnimateInOut from '../use-animate-in-out/use-animate-in-out';
import getMaxWindowScroll from '../window/get-max-window-scroll';
import useValidation from './use-validation';
import type {
  StateSnapshot as DraggableStateSnapshot,
  Provided as DraggableProvided,
} from '../draggable/draggable-types';
import AnimateInOut, {
  type AnimateProvided,
} from '../animate-in-out/animate-in-out';
import { PrivateDraggable } from '../draggable/draggable-api';

export default function Droppable(props: Props) {
  const appContext: ?AppContextValue = useContext<?AppContextValue>(AppContext);
  invariant(appContext, 'Could not find app context');
  const { contextId, isMovementAllowed } = appContext;
  const droppableRef = useRef<?HTMLElement>(null);
  const placeholderRef = useRef<?HTMLElement>(null);

  const {
    // own props
    children,
    droppableId,
    type,
    mode,
    direction,
    ignoreContainerClipping,
    isDropDisabled,
    isCombineEnabled,
    // map props
    snapshot,
    useClone,
    // dispatch props
    updateViewportMaxScroll,

    // clone (ownProps)
    getContainerForClone,
  } = props;

  const getDroppableRef = useCallback(
    (): ?HTMLElement => droppableRef.current,
    [],
  );
  const setDroppableRef = useCallback((value: ?HTMLElement) => {
    droppableRef.current = value;
  }, []);
  const getPlaceholderRef = useCallback(
    (): ?HTMLElement => placeholderRef.current,
    [],
  );
  const setPlaceholderRef = useCallback((value: ?HTMLElement) => {
    placeholderRef.current = value;
  }, []);

  useValidation({
    props,
    getDroppableRef,
    getPlaceholderRef,
  });

  const onPlaceholderTransitionEnd = useCallback(() => {
    // A placeholder change can impact the window's max scroll
    if (isMovementAllowed()) {
      updateViewportMaxScroll({ maxScroll: getMaxWindowScroll() });
    }
  }, [isMovementAllowed, updateViewportMaxScroll]);

  useDroppablePublisher({
    droppableId,
    type,
    mode,
    direction,
    isDropDisabled,
    isCombineEnabled,
    ignoreContainerClipping,
    getDroppableRef,
  });

  const placeholder: Node = (
    <AnimateInOut
      on={props.placeholder}
      shouldAnimate={props.shouldAnimatePlaceholder}
    >
      {({ onClose, data, animate }: AnimateProvided) => (
        <Placeholder
          placeholder={(data: any)}
          onClose={onClose}
          innerRef={setPlaceholderRef}
          animate={animate}
          contextId={contextId}
          onTransitionEnd={onPlaceholderTransitionEnd}
        />
      )}
    </AnimateInOut>
  );

  const provided: Provided = useMemo(
    (): Provided => ({
      innerRef: setDroppableRef,
      placeholder,
      droppableProps: {
        'data-rbd-droppable-id': droppableId,
        'data-rbd-droppable-context-id': contextId,
      },
    }),
    [contextId, droppableId, placeholder, setDroppableRef],
  );

  const isUsingCloneFor: ?DraggableId = useClone
    ? useClone.dragging.draggableId
    : null;

  const droppableContext: ?DroppableContextValue = useMemo(
    () => ({
      droppableId,
      type,
      isUsingCloneFor,
    }),
    [droppableId, isUsingCloneFor, type],
  );

  function getClone(): ?Node {
    if (!useClone) {
      return null;
    }
    const { dragging, render } = useClone;

    const node: Node = (
      <PrivateDraggable
        draggableId={dragging.draggableId}
        index={dragging.source.index}
        isClone
        isEnabled
        // not important as drag has already started
        shouldRespectForcePress={false}
        canDragInteractiveElements
      >
        {(
          draggableProvided: DraggableProvided,
          draggableSnapshot: DraggableStateSnapshot,
        ) => render(draggableProvided, draggableSnapshot, dragging)}
      </PrivateDraggable>
    );

    return ReactDOM.createPortal(node, getContainerForClone());
  }

  return (
    <DroppableContext.Provider value={droppableContext}>
      {children(provided, snapshot)}
      {getClone()}
    </DroppableContext.Provider>
  );
}

    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>node_modules\react-beautiful-dnd\src\view\placeholder\placeholder.jsx</file_path>
    <file_name>placeholder.jsx</file_name>
    <content>
    <![CDATA[
// @flow
import React, { useState, useRef, useEffect, type Node } from 'react';
import { useCallback } from 'use-memo-one';
import type { Spacing } from 'css-box-model';
import type {
  Placeholder as PlaceholderType,
  InOutAnimationMode,
  ContextId,
} from '../../types';
import { transitions } from '../../animation';
import { noSpacing } from '../../state/spacing';

function noop() {}

export type PlaceholderStyle = {|
  display: string,
  boxSizing: 'border-box',
  width: number,
  height: number,
  marginTop: number,
  marginRight: number,
  marginBottom: number,
  marginLeft: number,
  flexShrink: '0',
  flexGrow: '0',
  pointerEvents: 'none',
  transition: ?string,
|};
export type Props = {|
  placeholder: PlaceholderType,
  animate: InOutAnimationMode,
  onClose: () => void,
  innerRef?: () => ?HTMLElement,
  onTransitionEnd: () => void,
  contextId: ContextId,
|};

type Size = {|
  width: number,
  height: number,
  // Need to animate in/out animation as well as size
  margin: Spacing,
|};

type HelperArgs = {|
  isAnimatingOpenOnMount: boolean,
  placeholder: PlaceholderType,
  animate: InOutAnimationMode,
|};

const empty: Size = {
  width: 0,
  height: 0,
  margin: noSpacing,
};

const getSize = ({
  isAnimatingOpenOnMount,
  placeholder,
  animate,
}: HelperArgs): Size => {
  if (isAnimatingOpenOnMount) {
    return empty;
  }

  if (animate === 'close') {
    return empty;
  }

  return {
    height: placeholder.client.borderBox.height,
    width: placeholder.client.borderBox.width,
    margin: placeholder.client.margin,
  };
};

const getStyle = ({
  isAnimatingOpenOnMount,
  placeholder,
  animate,
}: HelperArgs): PlaceholderStyle => {
  const size: Size = getSize({ isAnimatingOpenOnMount, placeholder, animate });

  return {
    display: placeholder.display,
    // ## Recreating the box model
    // We created the borderBox and then apply the margins directly
    // this is to maintain any margin collapsing behaviour

    // creating borderBox
    // background: 'green',
    boxSizing: 'border-box',
    width: size.width,
    height: size.height,
    // creating marginBox
    marginTop: size.margin.top,
    marginRight: size.margin.right,
    marginBottom: size.margin.bottom,
    marginLeft: size.margin.left,

    // ## Avoiding collapsing
    // Avoiding the collapsing or growing of this element when pushed by flex child siblings.
    // We have already taken a snapshot the current dimensions we do not want this element
    // to recalculate its dimensions
    // It is okay for these properties to be applied on elements that are not flex children
    flexShrink: '0',
    flexGrow: '0',
    // Just a little performance optimisation: avoiding the browser needing
    // to worry about pointer events for this element
    pointerEvents: 'none',

    // Animate the placeholder size and margin
    transition: animate !== 'none' ? transitions.placeholder : null,
  };
};

function Placeholder(props: Props): Node {
  const animateOpenTimerRef = useRef<?TimeoutID>(null);

  const tryClearAnimateOpenTimer = useCallback(() => {
    if (!animateOpenTimerRef.current) {
      return;
    }
    clearTimeout(animateOpenTimerRef.current);
    animateOpenTimerRef.current = null;
  }, []);

  const { animate, onTransitionEnd, onClose, contextId } = props;
  const [isAnimatingOpenOnMount, setIsAnimatingOpenOnMount] = useState<boolean>(
    props.animate === 'open',
  );

  // Will run after a render is flushed
  // Still need to wait a timeout to ensure that the
  // update is completely applied to the DOM
  useEffect(() => {
    // No need to do anything
    if (!isAnimatingOpenOnMount) {
      return noop;
    }

    // might need to clear the timer
    if (animate !== 'open') {
      tryClearAnimateOpenTimer();
      setIsAnimatingOpenOnMount(false);
      return noop;
    }

    // timer already pending
    if (animateOpenTimerRef.current) {
      return noop;
    }

    animateOpenTimerRef.current = setTimeout(() => {
      animateOpenTimerRef.current = null;
      setIsAnimatingOpenOnMount(false);
    });

    // clear the timer if needed
    return tryClearAnimateOpenTimer;
  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);

  const onSizeChangeEnd = useCallback(
    (event: TransitionEvent) => {
      // We transition height, width and margin
      // each of those transitions will independently call this callback
      // Because they all have the same duration we can just respond to one of them
      // 'height' was chosen for no particular reason :D
      if (event.propertyName !== 'height') {
        return;
      }

      onTransitionEnd();

      if (animate === 'close') {
        onClose();
      }
    },
    [animate, onClose, onTransitionEnd],
  );

  const style: PlaceholderStyle = getStyle({
    isAnimatingOpenOnMount,
    animate: props.animate,
    placeholder: props.placeholder,
  });

  return React.createElement(props.placeholder.tagName, {
    style,
    'data-rbd-placeholder-context-id': contextId,
    onTransitionEnd: onSizeChangeEnd,
    ref: props.innerRef,
  });
}

export default React.memo<Props>(Placeholder);
// enzyme does not work well with memo, so exporting the non-memo version
export const WithoutMemo = Placeholder;

    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>src\components\Header.jsx</file_path>
    <file_name>Header.jsx</file_name>
    <content>
    <![CDATA[
import React from 'react';
import { Swords } from 'lucide-react';

const Header = () => {
  return (
    <header className="bg-gray-800 border-b border-gray-700">
      <div className="container mx-auto px-4 py-6">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="bg-blue-600 p-2 rounded-lg">
              <Swords size={24} className="text-white" />
            </div>
            <div>
              <h1 className="text-2xl font-bold text-white">Pokémon Team Calculator</h1>
              <p className="text-gray-400 text-sm">Build your perfect competitive team</p>
            </div>
          </div>
          
          <div className="hidden sm:flex items-center gap-4">
            <a 
              href="https://pokemondb.net/pokedex/"
              target="_blank"
              rel="noopener noreferrer"
              className="text-gray-300 hover:text-white transition-colors"
            >
              Pokédex
            </a>
            <a 
              href="https://pokemonshowdown.com/"
              target="_blank"
              rel="noopener noreferrer"
              className="text-gray-300 hover:text-white transition-colors"
            >
              Pokémon Showdown
            </a>
          </div>
        </div>
      </div>
    </header>
  );
};

export default Header;
    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>src\components\PokemonTeamCalculator.jsx</file_path>
    <file_name>PokemonTeamCalculator.jsx</file_name>
    <content>
    <![CDATA[
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { DragDropContext } from 'react-beautiful-dnd';
import axios from 'axios';
import localforage from 'localforage';
import { TypeChart } from '../data/typeChart';
import TeamBuilder from './TeamBuilder/TeamBuilder';
import BattleRecommendation from './BattleStrategy/BattleRecommendation';
import TeamRecommendations from './TeamBuilder/TeamRecommendations';
import PokemonTeamAnalyzer from './TeamBuilder/PokemonTeamAnalyzer'; 
import SearchInput from './Shared/SearchInput';
import PokemonDetailsModal from './Modals/PokemonDetailsModal';
import Header from './Header';
import {
  searchPokemon as searchPokemonCache,
  getPokemonDetails,
  getSpeciesDetails,
  getMoveDetails
} from '../utils/pokemonCache';

// Configure localforage
localforage.config({
  name: 'pokemon-cache',
  storeName: 'pokemon_data'
});

// Constants for storage keys
const STORAGE_KEYS = {
  TEAM: 'pokemon-team',
  OPPONENT: 'current-opponent',
  MOVE_DATA: 'pokemon-move-data',
  LAST_UPDATED: 'last-updated'
};

const fetchEvolutionData = async (pokemon) => {
  try {
    // Get species data which contains evolution chain URL
    const speciesResponse = await fetch(`https://pokeapi.co/api/v2/pokemon-species/${pokemon.name}`);
    const speciesData = await speciesResponse.json();
    
    // Fetch evolution chain data
    const evolutionResponse = await fetch(speciesData.evolution_chain.url);
    const evolutionData = await evolutionResponse.json();
    
    // Helper function to extract evolution chain
    const getEvolutionChain = (chain) => {
      const evolutions = [chain.species.name];
      let currentChain = chain;
      
      while (currentChain.evolves_to.length > 0) {
        // Get the first evolution path (most common)
        currentChain = currentChain.evolves_to[0];
        evolutions.push(currentChain.species.name);
      }
      
      return evolutions;
    };
    
    const evolutionChain = getEvolutionChain(evolutionData.chain);
    const currentIndex = evolutionChain.indexOf(pokemon.name);
    return currentIndex < evolutionChain.length - 1 ? evolutionChain[currentIndex + 1] : null;
    
  } catch (error) {
    console.error('Error fetching evolution data:', error);
    return null;
  }
};

const PokemonTeamCalculator = () => {
  const [team, setTeam] = useState([]);
  const [opponent, setOpponent] = useState(null);
  const [suggestions, setSuggestions] = useState({});
  const [searchTerm, setSearchTerm] = useState('');
  const [opponentSearch, setOpponentSearch] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [moveData, setMoveData] = useState({});
  const [selectedPokemon, setSelectedPokemon] = useState(null);

  // Load saved data on component mount
  useEffect(() => {
    const loadSavedData = async () => {
      try {
        const savedTeam = localStorage.getItem(STORAGE_KEYS.TEAM);
        if (savedTeam) {
          setTeam(JSON.parse(savedTeam));
        }

        const savedOpponent = localStorage.getItem(STORAGE_KEYS.OPPONENT);
        if (savedOpponent) {
          setOpponent(JSON.parse(savedOpponent));
        }

        const savedMoveData = localStorage.getItem(STORAGE_KEYS.MOVE_DATA);
        if (savedMoveData) {
          setMoveData(JSON.parse(savedMoveData));
        }
      } catch (error) {
        console.error('Error loading saved data:', error);
        localStorage.clear();
      }
    };

    loadSavedData();
  }, []);

  // Save data whenever it changes
  useEffect(() => {
    if (team.length > 0) {
      localStorage.setItem(STORAGE_KEYS.TEAM, JSON.stringify(team));
    }
    if (opponent) {
      localStorage.setItem(STORAGE_KEYS.OPPONENT, JSON.stringify(opponent));
    }
    if (Object.keys(moveData).length > 0) {
      localStorage.setItem(STORAGE_KEYS.MOVE_DATA, JSON.stringify(moveData));
    }
    localStorage.setItem(STORAGE_KEYS.LAST_UPDATED, new Date().toISOString());
  }, [team, opponent, moveData]);

  const searchPokemon = useCallback(async (query, isOpponent = false) => {
    if (query.length < 2) return;
    setLoading(true);
    try {
      const searchResults = await searchPokemonCache(query);
      if (searchResults.length > 0) {
        const pokemonData = await getPokemonDetails(searchResults[0].name);
        
        if (isOpponent) {
          setOpponent(pokemonData);
        } else {
          setSearchResults([pokemonData]);
          await loadMoveData(pokemonData);
        }
      }
    } catch (err) {
      setError('Pokémon not found');
    } finally {
      setLoading(false);
    }
  }, []);

  const loadMoveData = useCallback(async (pokemon) => {
    try {
      const moves = await Promise.all(
        pokemon.moves.slice(0, 4).map(async move => {
          const data = await getMoveDetails(move.move.url);
          return {
            name: data.name,
            type: data.type.name.toLowerCase(),
            power: data.power || 60,
            accuracy: data.accuracy || 100,
            pp: data.pp || 20
          };
        })
      );
      
      setMoveData(prev => ({
        ...prev,
        [pokemon.id]: moves
      }));
    } catch (err) {
      setError('Failed to load move data');
    }
  }, []);

  const calculateDamage = useCallback((attacker, move, defender) => {
    if (!defender?.types?.[0]) return 0;
    
    const level = 50;
    const attackStat = attacker.stats[1].base_stat;
    const defenseStat = defender.stats[2].base_stat;
    
    const base = Math.floor((2 * level) / 5 + 2);
    const damage = Math.floor(
      (base * move.power * (attackStat / defenseStat)) / 50 + 2
    );
    
    const stab = attacker.types.includes(move.type) ? 1.5 : 1;
    const effectiveness = TypeChart[move.type]?.strengths?.includes(defender.types[0]) ? 2 : 1;
    
    return Math.floor(damage * stab * effectiveness);
  }, []);

  const { coverage, weaknesses } = useMemo(() => {
    const coverage = new Set();
    const weaknesses = new Set();
    team.forEach(pokemon => {
      pokemon.types.forEach(type => {
        if (TypeChart[type]) {
          TypeChart[type].strengths.forEach(t => coverage.add(t));
          TypeChart[type].weaknesses.forEach(t => weaknesses.add(t));
        }
      });
    });
    return { coverage: [...coverage], weaknesses: [...weaknesses] };
  }, [team]);

  useEffect(() => {
    const newSuggestions = {
      addTypes: Object.keys(TypeChart).filter(type => 
        !coverage.includes(type) &&
        TypeChart[type].strengths.some(t => weaknesses.includes(t))
      ),
      replacePokemon: team.filter(pokemon => 
        pokemon.types.every(type => 
          TypeChart[type]?.weaknesses?.some(w => weaknesses.includes(w))
        )
      )
    };
    setSuggestions(newSuggestions);
  }, [coverage, weaknesses, team]);

  useEffect(() => {
    document.documentElement.classList.add('dark');
    return () => document.documentElement.classList.remove('dark');
  }, []);

  const battleRecommendation = useMemo(() => {
    if (!opponent) return null;
    return team.reduce((best, pokemon) => {
      const moves = moveData[pokemon.id] || [];
      const pokemonBest = moves.reduce((top, move) => {
        const damage = calculateDamage(pokemon, move, opponent);
        return damage > top.damage ? { move, damage } : top;
      }, { damage: 0 });
      return pokemonBest.damage > best.damage ? 
        { pokemon, ...pokemonBest } : best;
    }, { damage: 0 });
  }, [team, opponent, moveData, calculateDamage]);

  const handleDragEnd = async (result) => {
    if (!result.destination) return;
  
    const sourceIndex = result.source.index;
    const pokemon = team[sourceIndex];
  
    // Handle dropping into trash
    if (result.destination.droppableId === 'trash') {
      setTeam(team.filter((_, index) => index !== sourceIndex));
      return;
    }
  
    // Handle dropping into evolution zone
    if (result.destination.droppableId === 'evolution') {
      setLoading(true);
      try {
        const nextEvolution = await fetchEvolutionData(pokemon);
        
        if (nextEvolution) {
          // Fetch evolved Pokemon data
          const evolvedResponse = await fetch(`https://pokeapi.co/api/v2/pokemon/${nextEvolution}`);
          const evolvedPokemon = await evolvedResponse.json();
          
          // Replace the original Pokemon with its evolution
          const newTeam = [...team];
          newTeam[sourceIndex] = {
            ...evolvedPokemon,
            types: evolvedPokemon.types.map(t => t.type.name.toLowerCase())
          };
          setTeam(newTeam);
        } else {
          // No evolution available, just add the original back
          const newTeam = [...team];
          newTeam[sourceIndex] = pokemon;
          setTeam(newTeam);
        }
      } catch (error) {
        console.error('Error evolving Pokemon:', error);
        // In case of error, keep the original Pokemon
        const newTeam = [...team];
        newTeam[sourceIndex] = pokemon;
        setTeam(newTeam);
      }
      setLoading(false);
      return;
    }
  
    // Handle reordering within team
    if (result.destination.droppableId === 'team') {
      const items = Array.from(team);
      const [reorderedItem] = items.splice(sourceIndex, 1);
      items.splice(result.destination.index, 0, reorderedItem);
      setTeam(items);
    }
  };

  return (
    <div className="min-h-screen bg-gray-900 text-gray-100">
      <Header />
      <div className="container mx-auto px-4 py-8">
        {/* Mobile: Opponent Search First */}
        <div className="md:hidden mb-6">
          <div className="bg-gray-800 rounded-xl shadow-lg">
            <div className="p-6 border-b border-gray-700">
              <h2 className="text-xl font-bold text-white">Current Opponent</h2>
              <p className="text-gray-400 mt-1">Select your opponent</p>
            </div>
            <div className="p-6">
              <SearchInput
                label="Opponent"
                value={opponentSearch}
                onChange={(e) => {
                  setOpponentSearch(e.target.value);
                  searchPokemon(e.target.value, true);
                }}
                opponent={opponent}
              />
            </div>
          </div>

          {opponent && (
            <div className="bg-gray-800 rounded-xl shadow-lg mt-6">
              <div className="p-6 border-b border-gray-700">
                <h2 className="text-xl font-bold text-white">Battle Analysis</h2>
                <p className="text-gray-400 mt-1">Best matchup against current opponent</p>
              </div>
              <div className="p-6">
                <BattleRecommendation 
                  team={team}
                  opponent={opponent}
                  moveData={moveData}
                  calculateDamage={calculateDamage}
                  TypeChart={TypeChart}
                  battleRecommendation={battleRecommendation}
                />
              </div>
            </div>
          )}
        </div>

        <div className="flex flex-col md:flex-row gap-6">
          {/* Left Column - Team Builder */}
          <div className="w-full md:w-2/3">
            <div className="bg-gray-800 rounded-xl shadow-lg">
              <div className="p-6 border-b border-gray-700">
                <h2 className="text-2xl font-bold text-white">Your Team</h2>
                <p className="text-gray-400 mt-1">Build your perfect team of 6 Pokémon, tap on a pokemon to see its stats</p>
              </div>
              
              <DragDropContext onDragEnd={handleDragEnd}>
                <TeamBuilder 
                  team={team}
                  setTeam={setTeam}
                  searchTerm={searchTerm}
                  searchResults={searchResults}
                  loading={loading}
                  setSearchTerm={setSearchTerm}
                  setSelectedPokemon={setSelectedPokemon}
                  searchPokemon={searchPokemon}
                  setSearchResults={setSearchResults}
                />
              </DragDropContext>
            </div>

            {team.length > 0 && (
              <>
                <div className="mt-6">
                  <TeamRecommendations team={team} TypeChart={TypeChart} />
                </div>
                <div className="mt-6">
                  <PokemonTeamAnalyzer 
                    team={team}
                    setTeam={setTeam}
                    TypeChart={TypeChart}
                    onSelectPokemon={setSelectedPokemon}
                    searchPokemon={searchPokemon}
                    searchTerm={searchTerm}
                    setSearchTerm={setSearchTerm}
                    loading={loading}
                    searchResults={searchResults}
                  />
                </div>
              </>
            )}
          </div>

          {/* Right Column - Battle Info (Hidden on Mobile) */}
          <div className="hidden md:block w-full md:w-1/3">
            <div className="bg-gray-800 rounded-xl shadow-lg">
              <div className="p-6 border-b border-gray-700">
                <h2 className="text-xl font-bold text-white">Current Opponent</h2>
                <p className="text-gray-400 mt-1">Select your opponent</p>
              </div>
              <div className="p-6">
                <SearchInput
                  label="Opponent"
                  value={opponentSearch}
                  onChange={(e) => {
                    setOpponentSearch(e.target.value);
                    searchPokemon(e.target.value, true);
                  }}
                  opponent={opponent}
                />
              </div>
            </div>

            {opponent && (
              <div className="bg-gray-800 rounded-xl shadow-lg mt-6">
                <div className="p-6 border-b border-gray-700">
                  <h2 className="text-xl font-bold text-white">Battle Analysis</h2>
                  <p className="text-gray-400 mt-1">Best matchup against current opponent</p>
                </div>
                <div className="p-6">
                  <BattleRecommendation 
                    team={team}
                    opponent={opponent}
                    moveData={moveData}
                    calculateDamage={calculateDamage}
                    TypeChart={TypeChart}
                    battleRecommendation={battleRecommendation}
                  />
                </div>
              </div>
            )}
          </div>
        </div>

        <PokemonDetailsModal
          selectedPokemon={selectedPokemon}
          setSelectedPokemon={setSelectedPokemon}
          moveData={moveData}
          TypeChart={TypeChart}
        />
      </div>
    </div>
  );
};

export default PokemonTeamCalculator;
    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>src\components\BattleStrategy\BattleRecommendation.jsx</file_path>
    <file_name>BattleRecommendation.jsx</file_name>
    <content>
    <![CDATA[
import React, { useMemo } from 'react';
import TypeBadge from '../Shared/TypeBadge';
import { Shield, Swords, Scale } from 'lucide-react';
import SpeedComparison from './SpeedComparison'; 

const BattleRecommendation = ({ team, opponent, TypeChart }) => {
  // Get STAB attackers analysis
  const stabAnalysis = useMemo(() => {
    if (!opponent || !team.length) return [];
    
    return team.map(pokemon => {
      let bestStab = 0;
      let stabTypes = [];
      
      pokemon.types.forEach(attackType => {
        if (!TypeChart[attackType]) return;
        
        let multiplier = 1.5; // Base STAB bonus
        
        opponent.types.forEach(defenseType => {
          // Check for super effectiveness
          if (TypeChart[attackType].strengths.includes(defenseType)) {
            multiplier *= 2;
          }
          // Check for not very effective
          if (TypeChart[defenseType].resistances.includes(attackType)) {
            multiplier *= 0.5;
          }
          // Check for immunities
          if (TypeChart[defenseType].immunities.includes(attackType)) {
            multiplier = 0;
          }
        });
        
        if (multiplier > bestStab) {
          bestStab = multiplier;
          stabTypes = [attackType];
        } else if (multiplier === bestStab) {
          stabTypes.push(attackType);
        }
      });
      
      return {
        pokemon,
        stabMultiplier: bestStab,
        stabTypes,
        // Add base stats to factor into overall effectiveness
        attackStat: Math.max(pokemon.stats[1].base_stat, pokemon.stats[3].base_stat),
        speedStat: pokemon.stats[5].base_stat
      };
    }).filter(a => a.stabMultiplier > 0)
      .sort((a, b) => {
        const aScore = a.stabMultiplier * a.attackStat;
        const bScore = b.stabMultiplier * b.attackStat;
        return bScore - aScore;
      });
  }, [opponent, team, TypeChart]);

  const typeEffectiveness = useMemo(() => {
    if (!opponent) return {
      quad: [],
      double: [],
      neutral: [],
      half: [],
      quarter: [],
      zero: []
    };

    // Calculate effectiveness multipliers for each type
    const effectiveness = {};
    
    Object.keys(TypeChart).forEach(attackType => {
      let multiplier = 1;
      let isImmune = false;
      
      // Check immunities first
      opponent.types.forEach(defenseType => {
        if (TypeChart[defenseType].immunities.includes(attackType)) {
          isImmune = true;
        }
      });

      if (isImmune) {
        effectiveness[attackType] = 0;
        return;
      }

      // Calculate other type interactions
      opponent.types.forEach(defenseType => {
        // Super effective (2x)
        if (TypeChart[attackType].strengths.includes(defenseType)) {
          multiplier *= 2;
        }
        // Not very effective (0.5x) - if the defending type resists the attacking type
        if (TypeChart[defenseType].resistances.includes(attackType)) {
          multiplier *= 0.5;
        }
      });
      
      effectiveness[attackType] = multiplier;
    });

    // Group types by effectiveness
    const grouped = {
      quad: [], // 4x damage
      double: [], // 2x damage
      neutral: [], // 1x damage
      half: [], // 0.5x damage
      quarter: [], // 0.25x damage
      zero: [] // 0x damage (immunities)
    };

    Object.entries(effectiveness).forEach(([type, multiplier]) => {
      if (multiplier === 4) grouped.quad.push(type);
      else if (multiplier === 2) grouped.double.push(type);
      else if (multiplier === 1) grouped.neutral.push(type);
      else if (multiplier === 0.5) grouped.half.push(type);
      else if (multiplier === 0.25) grouped.quarter.push(type);
      else if (multiplier === 0) grouped.zero.push(type);
    });

    return grouped;
  }, [opponent, TypeChart]);

  if (!opponent) return null;

  // Find vulnerable Pokémon against the opponent
  const getVulnerablePokemon = () => {
    return team
      .map(pokemon => {
        // Calculate how many of the opponent's types are super effective
        const vulnerabilities = opponent.types.filter(oppType => 
          TypeChart[oppType]?.strengths.some(strength => 
            pokemon.types.includes(strength)
          )
        );

        // Calculate if the Pokémon is doubly weak
        const doubleWeakness = opponent.types.some(oppType =>
          pokemon.types.every(pokeType =>
            TypeChart[oppType]?.strengths.includes(pokeType)
          )
        );

        return {
          pokemon,
          vulnerabilities,
          doubleWeakness,
          vulnerabilityScore: vulnerabilities.length + (doubleWeakness ? 2 : 0)
        };
      })
      .filter(({ vulnerabilityScore }) => vulnerabilityScore > 0)
      .sort((a, b) => b.vulnerabilityScore - a.vulnerabilityScore);
  };

  const getBestDefenders = () => {
    return team.map(pokemon => {
      let bestResistance = 1;
      let bestResistanceType = '';

      opponent.types.forEach(attackType => {
        const typeInfo = TypeChart[attackType];
        if (!typeInfo) return;

        let resistance = 1;
        pokemon.types.forEach(defenseType => {
          if (typeInfo.weaknesses.includes(defenseType)) {
            resistance *= 0.5; // Resistant
          }
          if (typeInfo.strengths.includes(defenseType)) {
            resistance *= 2; // Weak
          }
        });

        if (resistance < bestResistance) {
          bestResistance = resistance;
          bestResistanceType = attackType;
        }
      });

      return {
        pokemon,
        resistance: bestResistance,
        type: bestResistanceType
      };
    })
    .sort((a, b) => a.resistance - b.resistance)
    .filter(({ resistance }) => resistance < 1);
  };

  const vulnerablePokemon = getVulnerablePokemon();
  const bestDefenders = getBestDefenders();

  const TypeSection = ({ types, multiplier, label, className }) => {
    if (!types.length) return null;
    return (
      <div className="mb-4">
        <div className="flex items-center gap-2 mb-2">
          <Scale className="h-4 w-4" />
          <span className={`text-sm font-medium ${className}`}>{label}</span>
        </div>
        <div className="flex flex-wrap gap-2">
          {types.map(type => (
            <TypeBadge key={type} type={type} small />
          ))}
        </div>
      </div>
    );
  };

  return (
    <div className="space-y-6">
      {/* Opponent Type Display */}
      <div className="bg-gray-700 rounded-xl p-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <img
              src={opponent.sprites.front_default}
              alt={opponent.name}
              className="w-12 h-12"
            />
            <div>
              <h3 className="text-lg font-semibold capitalize text-gray-100">
                {opponent.name}
              </h3>
              <div className="flex gap-1 mt-1">
                {opponent.types.map(type => (
                  <TypeBadge key={type} type={type} small />
                ))}
              </div>
            </div>
          </div>
        </div>
        <div className="mt-3 pt-3 border-t border-gray-600">
          <p className="text-sm text-gray-400 mb-1">EVs when defeated:</p>
          <div className="flex flex-wrap gap-2">
            {opponent.stats.map((stat, index) => {
              if (stat.effort === 0) return null;
              const statNames = ["HP", "Attack", "Defense", "Sp. Atk", "Sp. Def", "Speed"];
              return (
                <span key={index} className="text-sm bg-gray-600 text-gray-200 px-2 py-1 rounded-full">
                  {stat.effort} {statNames[index]}
                </span>
              );
            })}
          </div>
        </div>
      </div>

      

      {/* Type Effectiveness Breakdown */}
      <div className="bg-gray-700 rounded-xl p-4">
        <h3 className="text-lg font-semibold mb-4 text-gray-100">Weak Against</h3>
        
        <TypeSection 
          types={typeEffectiveness.quad}
          label="Super Effective (4x)"
          className="text-red-400"
        />
        
        <TypeSection 
          types={typeEffectiveness.double}
          label="Super Effective (2x)"
          className="text-orange-400"
        />
        
        <TypeSection 
          types={typeEffectiveness.half}
          label="Not Very Effective (0.5x)"
          className="text-blue-400"
        />
        
        <TypeSection 
          types={typeEffectiveness.quarter}
          label="Not Very Effective (0.25x)"
          className="text-blue-500"
        />
        
        {typeEffectiveness.zero.length > 0 && (
          <TypeSection 
            types={typeEffectiveness.zero}
            label="No Effect (0x)"
            className="text-purple-400"
          />
        )}
      </div>

      {/* Best Attackers Section */}
      {stabAnalysis.length > 0 && (
        <div className="bg-gray-700 rounded-xl p-4">
          <h3 className="text-lg font-semibold text-green-400 flex items-center gap-2 mb-3">
            <Swords className="h-5 w-5" />
            Best STAB Attackers
          </h3>
          <div className="space-y-3">
            {stabAnalysis.slice(0, 2).map(({ pokemon, stabMultiplier, stabTypes }) => (
              <div key={pokemon.id} className="flex items-center justify-between bg-gray-800 p-3 rounded-lg">
                <div className="flex items-center gap-3">
                  <img
                    src={pokemon.sprites.front_default}
                    alt={pokemon.name}
                    className="w-12 h-12"
                  />
                  <div>
                    <p className="font-medium capitalize text-gray-100">
                      {pokemon.name}
                    </p>
                    <div className="flex items-center gap-2 mt-1">
                      <span className="text-sm text-gray-400">Using</span>
                      {stabTypes.map(type => (
                        <TypeBadge key={type} type={type} small />
                      ))}
                    </div>
                  </div>
                </div>
                <div className="text-right">
                  <p className="text-lg font-bold text-green-400">
                    {(stabMultiplier * 100).toFixed(0)}%
                  </p>
                  <p className="text-sm text-gray-400">Damage</p>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Avoid Using Section */}
      {vulnerablePokemon.length > 0 && (
        <div className="bg-gray-700 rounded-xl p-4">
          <h3 className="text-lg font-semibold mb-3 text-red-400 flex items-center gap-2">
            <Shield className="h-5 w-5" />
            Avoid Using
          </h3>
          <div className="space-y-3">
            {vulnerablePokemon.map(({ pokemon, vulnerabilities, doubleWeakness }) => (
              <div key={pokemon.id} className="flex items-center justify-between bg-gray-800 p-3 rounded-lg">
                <div className="flex items-center gap-3">
                  <img
                    src={pokemon.sprites.front_default}
                    alt={pokemon.name}
                    className="w-12 h-12"
                  />
                  <div>
                    <p className="font-medium capitalize text-gray-100">
                      {pokemon.name}
                    </p>
                    <div className="flex items-center gap-2 mt-1">
                      <span className="text-sm text-red-400">
                        {doubleWeakness ? '4x weakness!' : 'Weak to:'}
                      </span>
                      {vulnerabilities.map(type => (
                        <TypeBadge key={type} type={type} small />
                      ))}
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Best Defenders */}
      {bestDefenders.length > 0 && (
        <div className="bg-gray-700 rounded-xl p-4">
          <h3 className="text-lg font-semibold mb-3 text-blue-400 flex items-center gap-2">
            <Shield className="h-5 w-5" />
            Best Defenders
          </h3>
          <div className="space-y-3">
            {bestDefenders.slice(0, 2).map(({ pokemon, type, resistance }) => (
              <div key={pokemon.id} className="flex items-center justify-between bg-gray-800 p-3 rounded-lg">
                <div className="flex items-center gap-3">
                  <img
                    src={pokemon.sprites.front_default}
                    alt={pokemon.name}
                    className="w-12 h-12"
                  />
                  <div>
                    <p className="font-medium capitalize text-gray-100">
                      {pokemon.name}
                    </p>
                    <div className="flex items-center gap-2 mt-1">
                      <span className="text-sm text-gray-400">Resists</span>
                      <TypeBadge type={type} small />
                    </div>
                  </div>
                </div>
                <span className="font-medium text-blue-400">
                  {resistance}x damage
                </span>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default BattleRecommendation;
    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>src\components\BattleStrategy\SpeedComparison.jsx</file_path>
    <file_name>SpeedComparison.jsx</file_name>
    <content>
    <![CDATA[
// src/components/BattleStrategy/SpeedComparison.jsx

import React, { useMemo } from 'react';
import { Zap } from 'lucide-react';

const SpeedComparison = ({ team, opponent }) => {
  const speedRanges = useMemo(() => {
    // Function to calculate speed range
    const getSpeedRange = (baseSpeed) => {
      // Minimum: Level 50, 0 IVs, 0 EVs, hindering nature
      const minSpeed = Math.floor(Math.floor((2 * baseSpeed) * 50 / 100 + 5) * 0.9);
      
      // Maximum: Level 50, 31 IVs, 252 EVs, beneficial nature
      const maxSpeed = Math.floor(Math.floor((2 * baseSpeed + 31 + 63) * 50 / 100 + 5) * 1.1);
      
      return { min: minSpeed, max: maxSpeed };
    };

    // Calculate ranges for team and opponent
    const teamSpeeds = team.map(pokemon => ({
      name: pokemon.name,
      baseSpeed: pokemon.stats[5].base_stat,
      ...getSpeedRange(pokemon.stats[5].base_stat)
    }));

    const opponentSpeed = opponent ? {
      name: opponent.name,
      baseSpeed: opponent.stats[5].base_stat,
      ...getSpeedRange(opponent.stats[5].base_stat)
    } : null;

    // Sort by maximum potential speed
    return {
      team: teamSpeeds.sort((a, b) => b.max - a.max),
      opponent: opponentSpeed
    };
  }, [team, opponent]);

  if (!opponent) return null;

  const { team: teamSpeeds, opponent: opponentSpeed } = speedRanges;

  // Function to determine speed comparison result
  const getSpeedComparison = (pokemon, opponent) => {
    if (pokemon.min > opponent.max) return 'Always Faster';
    if (pokemon.max < opponent.min) return 'Always Slower';
    return 'Speed Tie Possible';
  };

  // Function to get appropriate color class for comparison result
  const getComparisonColor = (result) => {
    switch (result) {
      case 'Always Faster': return 'text-green-400';
      case 'Always Slower': return 'text-red-400';
      default: return 'text-yellow-400';
    }
  };

  return (
    <div className="bg-gray-700 rounded-xl p-4">
      <h3 className="text-lg font-semibold text-white flex items-center gap-2 mb-4">
        <Zap className="h-5 w-5" />
        Speed Comparison
      </h3>

      <div className="space-y-3">
        <div className="grid grid-cols-[1fr,auto,1fr] gap-4 items-center text-sm text-gray-400 mb-2">
          <div>Your Pokémon</div>
          <div>Speed</div>
          <div>vs Opponent</div>
        </div>

        {teamSpeeds.map((pokemon) => (
          <div key={pokemon.name} className="grid grid-cols-[1fr,auto,1fr] gap-4 items-center bg-gray-600/50 rounded-lg p-3">
            <div className="font-medium capitalize text-gray-100">
              {pokemon.name}
            </div>
            <div className="text-center">
              <div className="text-sm text-gray-400">
                {pokemon.baseSpeed} base
              </div>
              <div className="text-xs text-gray-500">
                {pokemon.min} - {pokemon.max}
              </div>
            </div>
            <div>
              <div className={`font-medium ${getComparisonColor(getSpeedComparison(pokemon, opponentSpeed))}`}>
                {getSpeedComparison(pokemon, opponentSpeed)}
              </div>
              <div className="text-xs text-gray-500">
                vs {opponentSpeed.min} - {opponentSpeed.max}
              </div>
            </div>
          </div>
        ))}
      </div>

      <div className="mt-4 text-xs text-gray-400">
        <p>* Speed ranges assume Level 50 battles</p>
        <p>* Ranges account for natures, IVs, and EVs</p>
        <p>* Does not account for items, abilities, or status conditions</p>
      </div>
    </div>
  );
};

export default SpeedComparison;
    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>src\components\Modals\PokemonDetailsModal.jsx</file_path>
    <file_name>PokemonDetailsModal.jsx</file_name>
    <content>
    <![CDATA[
import React, { useState, useEffect } from 'react';
import TypeBadge from '../Shared/TypeBadge';
import { Shield, Swords, Zap } from 'lucide-react';

const StatBar = ({ value, maxValue = 255, label }) => (
  <div className="w-full">
    <div className="flex justify-between mb-1">
      <span className="text-sm font-medium text-gray-300">{label}</span>
      <span className="text-sm font-medium text-gray-400">{value}</span>
    </div>
    <div className="w-full bg-gray-700 rounded-full h-2.5">
      <div
        className="bg-blue-500 h-2.5 rounded-full"
        style={{ width: `${(value / maxValue) * 100}%` }}
      ></div>
    </div>
  </div>
);

const RoleIndicator = ({ stat, threshold, icon: Icon, label }) => {
  const isGood = stat >= threshold;
  return (
    <div className={`flex items-center gap-2 ${isGood ? 'text-green-400' : 'text-gray-500'}`}>
      <Icon size={16} />
      <span className="text-sm">{label}</span>
    </div>
  );
};

const PokemonDetailsModal = ({ selectedPokemon, setSelectedPokemon, moveData, TypeChart }) => {

    const [speciesData, setSpeciesData] = useState(null);
    const [recommendedMoves, setRecommendedMoves] = useState([]);
    const [loading, setLoading] = useState(true);
  
    useEffect(() => {
      const fetchSpeciesData = async () => {
        if (!selectedPokemon) return;
        
        setLoading(true);
        try {
          // Fetch species data for description
          const speciesResponse = await fetch(
            `https://pokeapi.co/api/v2/pokemon-species/${selectedPokemon.id}`
          );
          const speciesJson = await speciesResponse.json();
          
          // Get English flavor text
          const englishEntry = speciesJson.flavor_text_entries.find(
            entry => entry.language.name === 'en'
          );
          
          setSpeciesData({
            description: englishEntry ? englishEntry.flavor_text.replace(/\\f/g, ' ') : '',
            genus: speciesJson.genera.find(g => g.language.name === 'en')?.genus || ''
          });
  
          // Get recommended moves based on stats and type
          const allMoves = await Promise.all(
            selectedPokemon.moves
              .filter(move => {
                // Filter moves that are learned by level-up
                return move.version_group_details.some(
                  detail => detail.move_learn_method.name === 'level-up'
                );
              })
              .slice(0, 8) // Get first 8 moves to avoid too many requests
              .map(async move => {
                const moveResponse = await fetch(move.move.url);
                const moveData = await moveResponse.json();
                return {
                  name: moveData.name,
                  type: moveData.type.name,
                  power: moveData.power,
                  accuracy: moveData.accuracy,
                  pp: moveData.pp,
                  damage_class: moveData.damage_class.name,
                  priority: moveData.priority,
                  meta: moveData.meta
                };
              })
          );
  
          // Select recommended moves based on stats and types
          const recommended = allMoves
            .filter(move => move.power) // Only moves with power
            .sort((a, b) => {
              // Prioritize STAB moves
              const aStab = selectedPokemon.types.includes(a.type) ? 1.5 : 1;
              const bStab = selectedPokemon.types.includes(b.type) ? 1.5 : 1;
              
              // Consider physical/special split based on pokemon's stats
              const physicalBias = selectedPokemon.stats[1].base_stat > selectedPokemon.stats[3].base_stat;
              const aPhysical = a.damage_class === 'physical';
              const bPhysical = b.damage_class === 'physical';
              
              // Calculate move score
              const aScore = a.power * aStab * (aPhysical === physicalBias ? 1.2 : 1);
              const bScore = b.power * bStab * (bPhysical === physicalBias ? 1.2 : 1);
              
              return bScore - aScore;
            })
            .slice(0, 4); // Get top 4 recommended moves
  
          setRecommendedMoves(recommended);
          setLoading(false);
        } catch (error) {
          console.error('Error fetching additional data:', error);
          setLoading(false);
        }
      };
  
      fetchSpeciesData();
    }, [selectedPokemon]);
  
    if (!selectedPokemon) return null;
  
    const stats = {
      hp: selectedPokemon.stats[0].base_stat,
      attack: selectedPokemon.stats[1].base_stat,
      defense: selectedPokemon.stats[2].base_stat,
      specialAttack: selectedPokemon.stats[3].base_stat,
      specialDefense: selectedPokemon.stats[4].base_stat,
      speed: selectedPokemon.stats[5].base_stat
    };
  
    const totalStats = Object.values(stats).reduce((a, b) => a + b, 0);
  
    const StatBar = ({ value, maxValue = 255, label }) => (
      <div className="w-full">
        <div className="flex justify-between mb-1">
          <span className="text-sm font-medium text-gray-300">{label}</span>
          <span className="text-sm font-medium text-gray-400">{value}</span>
        </div>
        <div className="w-full bg-gray-700 rounded-full h-2.5">
          <div
            className="bg-blue-500 h-2.5 rounded-full"
            style={{ width: `${(value / maxValue) * 100}%` }}
          ></div>
        </div>
      </div>
    );
  
    const RoleIndicator = ({ stat, threshold, icon: Icon, label }) => {
      const isGood = stat >= threshold;
      return (
        <div className={`flex items-center gap-2 ${isGood ? 'text-green-400' : 'text-gray-500'}`}>
          <Icon size={16} />
          <span className="text-sm">{label}</span>
        </div>
      );
    };
  
    // Calculate potential roles based on stats
    const roles = [
      {
        icon: Swords,
        label: 'Physical Attacker',
        value: stats.attack >= 100
      },
      {
        icon: Swords,
        label: 'Special Attacker',
        value: stats.specialAttack >= 100
      },
      {
        icon: Shield,
        label: 'Physical Wall',
        value: stats.defense >= 100 && stats.hp >= 80
      },
      {
        icon: Shield,
        label: 'Special Wall',
        value: stats.specialDefense >= 100 && stats.hp >= 80
      },
      {
        icon: Zap,
        label: 'Fast Sweeper',
        value: stats.speed >= 100 && (stats.attack >= 90 || stats.specialAttack >= 90)
      }
    ].filter(role => role.value);
  
    return (
      <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
        <div className="bg-gray-800 rounded-xl max-w-4xl w-full max-h-[90vh] overflow-y-auto">
          {/* Header */}
          <div className="p-6 border-b border-gray-700">
            <div className="flex items-center justify-between">
              <h2 className="text-2xl font-bold capitalize text-white">
                {selectedPokemon.name}
              </h2>
              <div className="flex gap-2">
                {selectedPokemon.types.map((type) => (
                  <TypeBadge key={type} type={type} />
                ))}
              </div>
            </div>
          </div>
  
          <div className="p-6">
            <div className="grid md:grid-cols-2 gap-8">
              {/* Left Column */}
              <div>
                {/* Sprite and Basic Info */}
                <div className="bg-gray-700/50 rounded-xl p-6 text-center mb-6">
                  <img
                    src={selectedPokemon.sprites.front_default}
                    alt={selectedPokemon.name}
                    className="w-40 h-40 mx-auto"
                  />
                  <div className="mt-4">
                    <p className="text-gray-300">Height: {selectedPokemon.height / 10}m</p>
                    <p className="text-gray-300">Weight: {selectedPokemon.weight / 10}kg</p>
                  </div>
                </div>
  
                {/* Description */}
                {speciesData && (
                  <div className="bg-gray-700/50 rounded-xl p-6 mb-6">
                    <h3 className="text-xl font-semibold mb-2 text-white">About</h3>
                    <p className="text-gray-300 italic mb-2">{speciesData.genus}</p>
                    <p className="text-gray-300">{speciesData.description}</p>
                  </div>
                )}
  
                {/* Type Effectiveness */}
                <div className="bg-gray-700/50 rounded-xl p-6 mb-6">
                  <h3 className="text-xl font-semibold mb-4 text-white">Type Effectiveness (Defensive)</h3>
                  {(() => {
                    // Calculate effectiveness multipliers for each type
                    const effectiveness = {};
                    
                    Object.keys(TypeChart).forEach(attackType => {
                      let multiplier = 1;
                      let isImmune = false;
                      
                      // Check immunities first
                      selectedPokemon.types.forEach(defenseType => {
                        if (TypeChart[defenseType].immunities.includes(attackType)) {
                          isImmune = true;
                        }
                      });

                      if (isImmune) {
                        effectiveness[attackType] = 0;
                        return;
                      }

                      // Calculate other type interactions
                      selectedPokemon.types.forEach(defenseType => {
                        // Not very effective (0.5x) - if the defending type resists the attacking type
                        if (TypeChart[defenseType].resistances.includes(attackType)) {
                          multiplier *= 0.5;
                        }
                        // Super effective (2x)
                        if (TypeChart[attackType].strengths.includes(defenseType)) {
                          multiplier *= 2;
                        }
                      });
                      
                      effectiveness[attackType] = multiplier;
                    });

                    // Group types by effectiveness
                    const typesByEffectiveness = {
                      quad: [], // 4x damage
                      double: [], // 2x damage
                      half: [], // 0.5x damage
                      quarter: [], // 0.25x damage
                      zero: [] // 0x damage (immunities)
                    };

                    Object.entries(effectiveness).forEach(([type, multiplier]) => {
                      if (multiplier === 4) typesByEffectiveness.quad.push(type);
                      else if (multiplier === 2) typesByEffectiveness.double.push(type);
                      else if (multiplier === 0.5) typesByEffectiveness.half.push(type);
                      else if (multiplier === 0.25) typesByEffectiveness.quarter.push(type);
                      else if (multiplier === 0) typesByEffectiveness.zero.push(type);
                    });

                    return (
                      <div className="space-y-4">
                        {typesByEffectiveness.quad.length > 0 && (
                          <div>
                            <p className="text-sm text-red-400 mb-2">Super Effective (4x):</p>
                            <div className="flex flex-wrap gap-2">
                              {typesByEffectiveness.quad.map(type => (
                                <TypeBadge key={type} type={type} small />
                              ))}
                            </div>
                          </div>
                        )}
                        
                        {typesByEffectiveness.double.length > 0 && (
                          <div>
                            <p className="text-sm text-orange-400 mb-2">Super Effective (2x):</p>
                            <div className="flex flex-wrap gap-2">
                              {typesByEffectiveness.double.map(type => (
                                <TypeBadge key={type} type={type} small />
                              ))}
                            </div>
                          </div>
                        )}
                        
                        {typesByEffectiveness.half.length > 0 && (
                          <div>
                            <p className="text-sm text-blue-400 mb-2">Not Very Effective (0.5x):</p>
                            <div className="flex flex-wrap gap-2">
                              {typesByEffectiveness.half.map(type => (
                                <TypeBadge key={type} type={type} small />
                              ))}
                            </div>
                          </div>
                        )}
                        
                        {typesByEffectiveness.quarter.length > 0 && (
                          <div>
                            <p className="text-sm text-blue-500 mb-2">Not Very Effective (0.25x):</p>
                            <div className="flex flex-wrap gap-2">
                              {typesByEffectiveness.quarter.map(type => (
                                <TypeBadge key={type} type={type} small />
                              ))}
                            </div>
                          </div>
                        )}
                        
                        {typesByEffectiveness.zero.length > 0 && (
                          <div>
                            <p className="text-sm text-purple-400 mb-2">No Effect (0x):</p>
                            <div className="flex flex-wrap gap-2">
                              {typesByEffectiveness.zero.map(type => (
                                <TypeBadge key={type} type={type} small />
                              ))}
                            </div>
                          </div>
                        )}
                      </div>
                    );
                  })()}
                </div>

                {/* Moves */}
                <div className="bg-gray-700/50 rounded-xl p-6">
                  <h3 className="text-xl font-semibold mb-4 text-white">
                    Recommended Moves
                  </h3>
                  {loading ? (
                    <div className="text-center text-gray-400">Loading moves...</div>
                  ) : (
                    <div className="space-y-3">
                      {recommendedMoves.map((move) => (
                        <div
                          key={move.name}
                          className="flex items-center justify-between bg-gray-600/50 rounded-lg p-3"
                        >
                          <div>
                            <p className="capitalize text-gray-100">{move.name}</p>
                            <div className="flex items-center gap-2 mt-1">
                              <TypeBadge type={move.type} small />
                              <span className="text-sm text-gray-400">
                                {move.damage_class === 'physical' ? 'Physical' : 'Special'}
                              </span>
                            </div>
                          </div>
                          <div className="text-right">
                            <p className="text-gray-100">{move.power || '-'} Power</p>
                            <p className="text-sm text-gray-400">{move.accuracy || 100}% Accuracy</p>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
  
              {/* Right Column */}
              <div className="space-y-6">
                {/* Base Stats */}
                <div className="bg-gray-700/50 rounded-xl p-6">
                  <h3 className="text-xl font-semibold mb-4 text-white">Base Stats</h3>
                  <div className="space-y-4">
                    <StatBar value={stats.hp} label="HP" />
                    <StatBar value={stats.attack} label="Attack" />
                    <StatBar value={stats.defense} label="Defense" />
                    <StatBar value={stats.specialAttack} label="Sp. Attack" />
                    <StatBar value={stats.specialDefense} label="Sp. Defense" />
                    <StatBar value={stats.speed} label="Speed" />
                  </div>
                  <div className="mt-4 pt-4 border-t border-gray-600">
                    <p className="text-gray-300">
                      Total: <span className="font-bold text-white">{totalStats}</span>
                    </p>
                  </div>
                </div>
  
                {/* Potential Roles */}
                <div className="bg-gray-700/50 rounded-xl p-6">
                  <h3 className="text-xl font-semibold mb-4 text-white">Potential Roles</h3>
                  <div className="grid grid-cols-2 gap-3">
                    <RoleIndicator
                      stat={stats.attack}
                      threshold={100}
                      icon={Swords}
                      label="Physical Attacker"
                    />
                    <RoleIndicator
                      stat={stats.specialAttack}
                      threshold={100}
                      icon={Swords}
                      label="Special Attacker"
                    />
                    <RoleIndicator
                      stat={stats.defense}
                      threshold={100}
                      icon={Shield}
                      label="Physical Wall"
                    />
                    <RoleIndicator
                      stat={stats.specialDefense}
                      threshold={100}
                      icon={Shield}
                      label="Special Wall"
                    />
                    <RoleIndicator
                      stat={stats.speed}
                      threshold={100}
                      icon={Zap}
                      label="Speed Sweeper"
                    />
                  </div>
                </div>
              </div>
            </div>
          </div>
  
          {/* Footer */}
          <div className="p-6 border-t border-gray-700">
            <button
              onClick={() => setSelectedPokemon(null)}
              className="w-full bg-blue-600 hover:bg-blue-700 text-white py-2.5 rounded-xl transition-colors font-medium"
            >
              Close
            </button>
          </div>
        </div>
      </div>
    );
  };
  
  export default PokemonDetailsModal;
    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>src\components\Shared\SearchInput.jsx</file_path>
    <file_name>SearchInput.jsx</file_name>
    <content>
    <![CDATA[
import React, { useState, useEffect } from 'react';
import TypeBadge from './TypeBadge';

const SearchInput = ({
  label,
  value,
  onChange,
  loading,
  searchResults,
  onSelect,
  opponent,
  isOpponentSearch
}) => {
  const [suggestions, setSuggestions] = useState([]);
  const [showSuggestions, setShowSuggestions] = useState(false);

  useEffect(() => {
    const fetchSuggestions = async () => {
      if (value.length < 2) {
        setSuggestions([]);
        return;
      }

      try {
        const response = await fetch('https://pokeapi.co/api/v2/pokemon?limit=2000');
        const data = await response.json();
        
        const filtered = data.results
          .filter(pokemon => {
            const name = pokemon.name.toLowerCase();
            const search = value.toLowerCase();
            return (
              name.startsWith(search) ||
              name.includes(search)
            );
          })
          .sort((a, b) => {
            const aName = a.name.toLowerCase();
            const bName = b.name.toLowerCase();
            const search = value.toLowerCase();
            
            const aStartsWith = aName.startsWith(search);
            const bStartsWith = bName.startsWith(search);
            
            if (aStartsWith && !bStartsWith) return -1;
            if (!aStartsWith && bStartsWith) return 1;
            return aName.localeCompare(bName);
          })
          .slice(0, 8);

        setSuggestions(filtered);
        setShowSuggestions(true);
      } catch (error) {
        console.error('Error fetching suggestions:', error);
      }
    };

    fetchSuggestions();
  }, [value]);

  const handleSuggestionClick = async (suggestion) => {
    try {
      const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${suggestion.name}`);
      const pokemonData = await response.json();
      const processedPokemon = {
        ...pokemonData,
        types: pokemonData.types.map(t => t.type.name.toLowerCase())
      };
      
      // Update input value
      onChange({ target: { value: suggestion.name } });
      
      // Call onSelect with the processed pokemon data
      onSelect(processedPokemon);
      
      // Hide suggestions
      setShowSuggestions(false);
      
      // Clear input only for team pokemon search, not opponent
      if (!isOpponentSearch) {
        onChange({ target: { value: '' } });
      }
    } catch (error) {
      console.error('Error fetching Pokemon details:', error);
    }
  };

  // Handle clicking outside of the search component
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (!event.target.closest('.search-container')) {
        setShowSuggestions(false);
      }
    };

    document.addEventListener('click', handleClickOutside);
    return () => document.removeEventListener('click', handleClickOutside);
  }, []);

  return (
    <div className="relative mb-4 search-container">
      <input
        type="text"
        placeholder={`Search ${label || 'Pokémon'}...`}
        className="w-full p-3 bg-gray-800 border border-gray-700 rounded-xl 
                 focus:outline-none focus:ring-2 focus:ring-blue-500 
                 text-gray-100 placeholder-gray-500"
        value={value}
        onChange={onChange}
        onFocus={() => setShowSuggestions(value.length >= 2)}
      />
      
      {loading && (
        <div className="absolute right-3 top-3 animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500" />
      )}

      {/* Suggestions Dropdown */}
      {showSuggestions && suggestions.length > 0 && (
        <div className="absolute z-50 w-full mt-1 bg-gray-800 border border-gray-700 
                      rounded-xl shadow-lg max-h-80 overflow-y-auto">
          {suggestions.map((suggestion) => (
            <button
              key={suggestion.name}
              className="w-full text-left px-4 py-3 hover:bg-gray-700 
                       transition-colors cursor-pointer border-b border-gray-700
                       last:border-b-0 capitalize text-gray-100"
              onClick={() => handleSuggestionClick(suggestion)}
            >
              {suggestion.name}
            </button>
          ))}
        </div>
      )}

      {opponent && (
        <div className="mt-4 p-4 bg-gray-700 rounded-xl">
          <div className="flex items-center">
            <img
              src={opponent.sprites.front_default}
              alt={opponent.name}
              className="w-16 h-16 mr-4"
            />
            <div>
              <h3 className="text-xl font-bold capitalize text-gray-100">
                {opponent.name}
              </h3>
              <div className="flex gap-1 mt-1">
                {opponent.types.map(type => (
                  <TypeBadge key={type} type={type} small />
                ))}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default SearchInput;
    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>src\components\Shared\StatsChart.jsx</file_path>
    <file_name>StatsChart.jsx</file_name>
    <content>
    <![CDATA[
import { VictoryBar, VictoryChart, VictoryTheme, VictoryTooltip } from 'victory';

const StatsChart = ({ pokemon }) => {
  const statsData = pokemon.stats.map((stat, index) => ({
    stat: ['HP', 'Attack', 'Defense', 'Sp.Atk', 'Sp.Def', 'Speed'][index],
    value: stat.base_stat
  }));

  return (
    <div className="overflow-x-auto">
      <VictoryChart
        theme={VictoryTheme.material}
        domainPadding={20}
        height={300}
        width={600}
        padding={{ top: 20, bottom: 50, left: 50, right: 20 }}
      >
        <VictoryBar
          data={statsData}
          x="stat"
          y="value"
          labels={({ datum }) => `${datum.value}`}
          labelComponent={<VictoryTooltip />}
          style={{
            data: { fill: "#4F46E5", width: 30 },
            labels: { fontSize: 12 }
          }}
        />
      </VictoryChart>
    </div>
  );
};

export default StatsChart;

    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>src\components\Shared\TypeBadge.jsx</file_path>
    <file_name>TypeBadge.jsx</file_name>
    <content>
    <![CDATA[
import { typeColors } from '../../data/typeColors';

const TypeBadge = ({ type, small = false }) => (
  <span className={`${typeColors[type]} ${
    small ? 'px-2 py-1 text-xs' : 'px-3 py-1.5 text-sm'
  } text-white rounded-full font-medium capitalize`}>
    {type}
  </span>
);

export default TypeBadge;

    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>src\components\TeamBuilder\EvolutionZone.jsx</file_path>
    <file_name>EvolutionZone.jsx</file_name>
    <content>
    <![CDATA[
import React from 'react';
import { ArrowUpCircle } from 'lucide-react';

const EvolutionZone = ({ isDraggingOver }) => {
  return (
    <div className={`flex items-center justify-center h-20 border-2 border-dashed 
                   rounded-xl transition-colors ${
      isDraggingOver 
        ? 'border-blue-500 bg-blue-500/10' 
        : 'border-gray-700 bg-gray-800/50'
    }`}>
      <div className="flex items-center gap-2 text-gray-400">
        <ArrowUpCircle className={`w-6 h-6 ${
          isDraggingOver ? 'text-blue-500' : 'text-gray-500'
        }`} />
        <span className={isDraggingOver ? 'text-blue-500' : ''}>
          Drop to evolve Pokémon
        </span>
      </div>
    </div>
  );
};

export default EvolutionZone;
    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>src\components\TeamBuilder\PokemonCard.jsx</file_path>
    <file_name>PokemonCard.jsx</file_name>
    <content>
    <![CDATA[
import React from 'react';
import { Draggable } from 'react-beautiful-dnd';
import { X } from 'lucide-react';
import TypeBadge from '../Shared/TypeBadge';

// Stat badge colors and icons using tailwind classes
const statConfig = {
  hp: {
    color: 'bg-red-500',
    icon: '❤️',
    label: 'HP'
  },
  attack: {
    color: 'bg-orange-500',
    icon: '⚔️',
    label: 'Atk'
  },
  defense: {
    color: 'bg-yellow-500',
    icon: '🛡️',
    label: 'Def'
  },
  'special-attack': {
    color: 'bg-purple-500',
    icon: '✨',
    label: 'Sp.Atk'
  },
  'special-defense': {
    color: 'bg-green-500',
    icon: '🌟',
    label: 'Sp.Def'
  },
  speed: {
    color: 'bg-blue-500',
    icon: '⚡',
    label: 'Spd'
  }
};

const StatBadge = ({ stat, value }) => {
  const config = statConfig[stat];
  
  return (
    <div className={`flex items-center px-2 py-1 rounded-full ${config.color} 
                    text-white text-xs font-medium shadow-sm`}>
      <span className="mr-1">{config.icon}</span>
      <span>{config.label}</span>
    </div>
  );
};

// Function to get the two highest stats
const getTopStats = (stats) => {
  const formattedStats = stats.map((stat, index) => ({
    name: ['hp', 'attack', 'defense', 'special-attack', 'special-defense', 'speed'][index],
    value: stat.base_stat
  }));

  return formattedStats
    .sort((a, b) => b.value - a.value)
    .slice(0, 2);
};

const PokemonCard = ({ pokemon, index, onClick }) => {
  const topStats = getTopStats(pokemon.stats);

  return (
    <Draggable draggableId={`pokemon-${pokemon.id}`} index={index}>
      {(provided, snapshot) => (
        <div
          ref={provided.innerRef}
          {...provided.draggableProps}
          {...provided.dragHandleProps}
          className={`
            bg-gray-800 rounded-xl shadow-sm hover:shadow-md transition-all 
            transform hover:-translate-y-1 cursor-move relative group
            ${snapshot.isDragging ? 'shadow-lg ring-2 ring-blue-400' : ''}
          `}
        >
          <div 
            className="p-3"
            onClick={() => onClick(pokemon)}
          >
            <div className="relative bg-gray-700/50 rounded-lg p-2">
              <img
                src={pokemon.sprites.front_default}
                alt={pokemon.name}
                className="w-full h-24 object-contain mx-auto"
              />
              <h3 className="text-center text-sm font-medium capitalize mb-2 text-gray-100">
                {pokemon.name}
              </h3>
            </div>
            
            {/* Types */}
            <div className="flex flex-wrap gap-1 justify-center mt-2">
              {pokemon.types.map(type => (
                <TypeBadge key={type} type={type} small />
              ))}
            </div>

            {/* Stat Badges */}
            <div className="flex flex-wrap gap-1 justify-center mt-2">
              {topStats.map(stat => (
                <StatBadge key={stat.name} stat={stat.name} value={stat.value} />
              ))}
            </div>
          </div>
        </div>
      )}
    </Draggable>
  );
};

export { PokemonCard, StatBadge, getTopStats };
    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>src\components\TeamBuilder\PokemonTeamAnalyzer.jsx</file_path>
    <file_name>PokemonTeamAnalyzer.jsx</file_name>
    <content>
    <![CDATA[
import React, { useState, useMemo } from 'react';
import SearchInput from '../Shared/SearchInput';
import TypeBadge from '../Shared/TypeBadge';
import { Shield, Swords, ArrowRight, Plus } from 'lucide-react';

const PokemonTeamAnalyzer = ({ 
  team, 
  setTeam, 
  TypeChart,
  onSelectPokemon,
  searchPokemon,
  searchTerm,
  setSearchTerm,
  loading,
  searchResults
}) => {
  const [candidatePokemon, setCandidatePokemon] = useState(null);

  const analysis = useMemo(() => {
    if (!candidatePokemon || !team.length) return null;

    // Get current team's type coverage and weaknesses
    const teamTypes = new Set();
    const teamWeaknesses = new Set();
    const teamResistances = new Set();

    // Track existing STAB coverage and potential coverage separately
    const existingStabCoverage = new Set();
    const existingPotentialCoverage = new Set();
    
    team.forEach(pokemon => {
      pokemon.types.forEach(type => {
        teamTypes.add(type);
        
        // Add weaknesses and resistances
        Object.entries(TypeChart).forEach(([attackType, info]) => {
          // Check for weaknesses (if the attacking type is super effective)
          if (info.strengths.includes(type) && 
              !TypeChart[type].resistances.includes(attackType) &&
              !TypeChart[type].immunities.includes(attackType)) {
            teamWeaknesses.add(attackType);
          }
          // Check for resistances and immunities
          if (TypeChart[type].resistances.includes(attackType) ||
              TypeChart[type].immunities.includes(attackType)) {
            teamResistances.add(attackType);
          }
        });

        // Add STAB coverage
        if (TypeChart[type]) {
          TypeChart[type].strengths.forEach(t => existingStabCoverage.add(t));
        }
      });

      // Add potential coverage from moves if available
      if (pokemon.moves) {
        pokemon.moves.forEach(move => {
          if (TypeChart[move.type]) {
            TypeChart[move.type].strengths.forEach(t => existingPotentialCoverage.add(t));
          }
        });
      }
    });

    // Calculate type redundancy
    const typeRedundancyCount = candidatePokemon.types.reduce((count, type) => {
      return count + (Array.from(teamTypes).filter(t => t === type).length);
    }, 0);

    // Analyze candidate's contribution
    const newTypes = candidatePokemon.types.filter(type => !teamTypes.has(type));
    const newStabCoverage = new Set();
    const newPotentialCoverage = new Set();
    const candidateWeaknesses = new Set();
    const newResistances = new Set();
    const newImmunities = new Set();
    
    // Add STAB coverage and calculate defensive contributions
    candidatePokemon.types.forEach(type => {
      if (TypeChart[type]) {
        // Add new STAB coverage
        TypeChart[type].strengths.forEach(t => {
          if (!existingStabCoverage.has(t)) {
            newStabCoverage.add(t);
          }
        });

        // Add new resistances and immunities
        TypeChart[type].resistances.forEach(resistedType => {
          if (!teamResistances.has(resistedType)) {
            newResistances.add(resistedType);
          }
        });

        TypeChart[type].immunities.forEach(immuneType => {
          if (!teamResistances.has(immuneType)) {
            newImmunities.add(immuneType);
          }
        });

        // Calculate weaknesses
        Object.entries(TypeChart).forEach(([attackType, info]) => {
          // Add to weaknesses only if the type isn't resistant or immune
          if (info.strengths.includes(type) && 
              !TypeChart[type].resistances.includes(attackType) &&
              !TypeChart[type].immunities.includes(attackType)) {
            candidateWeaknesses.add(attackType);
          }
        });
      }
    });

    // Add potential coverage from moves if available
    if (candidatePokemon.moves) {
      candidatePokemon.moves.forEach(move => {
        if (TypeChart[move.type]) {
          TypeChart[move.type].strengths.forEach(t => {
            if (!existingStabCoverage.has(t) && !existingPotentialCoverage.has(t)) {
              newPotentialCoverage.add(t);
            }
          });
        }
      });
    }

    // Find potential replacements if team is full
    const replacementSuggestions = team.length === 6 ? team
      .map(pokemon => {
        // Calculate overlap score (lower is better for replacement)
        const typeOverlap = pokemon.types.filter(type => 
          teamTypes.has(type)).length;
        
        // Calculate weakness overlap
        const weaknessOverlap = pokemon.types.filter(type =>
          Array.from(teamWeaknesses).some(weakness => 
            TypeChart[weakness]?.strengths.includes(type)
          )).length;

        // Calculate unique coverage loss
        const uniqueCoverage = pokemon.types.some(type =>
          TypeChart[type]?.strengths.some(strength =>
            !Array.from(teamTypes).some(t => 
              t !== type && TypeChart[t]?.strengths.includes(strength)
            )
          )
        );

        return {
          pokemon,
          score: typeOverlap + weaknessOverlap + (uniqueCoverage ? 2 : 0),
          reasons: {
            typeOverlap,
            weaknessOverlap,
            uniqueCoverage
          }
        };
      })
      .sort((a, b) => b.score - a.score)
      .slice(0, 2)
      : [];

    // Calculate synergy score (0-100)
    const synergyScore = Math.min(100, Math.round(
      (newTypes.length * 15) + // New type bonus 
      (newStabCoverage.size * 15) + // STAB coverage bonus (higher weight)
      (newPotentialCoverage.size * 5) + // Potential coverage bonus (lower weight)
      (Array.from(candidateWeaknesses).filter(w => !teamWeaknesses.has(w)).length * -15) + // New weakness penalty
      (Array.from(teamResistances).filter(r => 
        candidatePokemon.types.some(t => 
          TypeChart[t].resistances.includes(r) || 
          TypeChart[t].immunities.includes(r)
        )).length * 8) + // Resistance/immunity bonus
      (newResistances.size * 12) + // Bonus for new resistances
      (newImmunities.size * 18) + // Higher bonus for new immunities
      (candidatePokemon.types.length > 1 ? 10 : 0) + // Dual-type bonus
      (typeRedundancyCount * -20) + // Heavy penalty for duplicate types
      50 // Base score
    ));

    return {
      newTypes,
      newStabCoverage,
      newPotentialCoverage,
      newResistances,
      newImmunities,
      sharedWeaknesses: Array.from(candidateWeaknesses).filter(w => teamWeaknesses.has(w)),
      replacementSuggestions,
      synergyScore
    };
  }, [candidatePokemon, team, TypeChart]);

  const handleAddPokemon = () => {
    if (!candidatePokemon) return;
    
    if (team.length < 6) {
      setTeam([...team, candidatePokemon]);
    } else if (analysis?.replacementSuggestions[0]) {
      const newTeam = team.map(p => 
        p.id === analysis.replacementSuggestions[0].pokemon.id ? candidatePokemon : p
      );
      setTeam(newTeam);
    }
    setCandidatePokemon(null);
  };

  return (
    <div className="bg-gray-800 rounded-xl p-6">
      <h2 className="text-xl font-bold text-white mb-4">Team Addition Analyzer</h2>
      <p className="text-gray-400 mb-4">
        Search for a Pokémon to analyze how well it would fit with your current team
      </p>

      <SearchInput
        label="Analyze Pokémon"
        value={searchTerm}
        onChange={(e) => {
          setSearchTerm(e.target.value);
          searchPokemon(e.target.value);
        }}
        loading={loading}
        searchResults={searchResults}
        onSelect={(pokemon) => {
          setCandidatePokemon(pokemon);
          setSearchTerm('');
        }}
      />

      {candidatePokemon && (
        <div className="mt-6 space-y-6">
          {/* Candidate Pokemon Card */}
          <div className="bg-gray-700 rounded-xl p-4">
            <div className="flex items-center gap-4">
              <img
                src={candidatePokemon.sprites.front_default}
                alt={candidatePokemon.name}
                className="w-16 h-16"
              />
              <div>
                <h3 className="text-lg font-semibold capitalize text-white">
                  {candidatePokemon.name}
                </h3>
                <a
                  href={`https://pokemondb.net/pokedex/${candidatePokemon.name.toLowerCase()}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-400 hover:text-blue-300 text-sm transition-colors"
                >
                  Pokédex Entry ↗
                </a>

                <div className="flex gap-2 mt-1">
                  {candidatePokemon.types.map(type => (
                    <TypeBadge key={type} type={type} small />
                  ))}
                </div>
              </div>
              {analysis && (
                <div className="ml-auto text-right">
                  <div className="text-2xl font-bold text-white">
                    {analysis.synergyScore}%
                  </div>
                  <div className="text-sm text-gray-400">Synergy Score</div>
                </div>
              )}
            </div>
          </div>

          {analysis && (
            <>
              {/* New Contributions */}
              {(analysis.newStabCoverage.size > 0 || analysis.newPotentialCoverage.size > 0 || 
                analysis.newResistances.size > 0 || analysis.newImmunities.size > 0) && (
                <div className="bg-gray-700 rounded-xl p-4">
                  <h3 className="text-lg font-semibold text-green-400 flex items-center gap-2 mb-3">
                    <Plus className="h-5 w-5" />
                    New Contributions
                  </h3>
                  
                  {/* Offensive Coverage */}
                  {analysis.newStabCoverage.size > 0 && (
                    <div className="mb-3">
                      <p className="text-sm text-gray-400 mb-2">New Guaranteed Coverage (STAB):</p>
                      <div className="flex flex-wrap gap-2">
                        {Array.from(analysis.newStabCoverage).map(type => (
                          <TypeBadge key={type} type={type} small />
                        ))}
                      </div>
                    </div>
                  )}

                  {analysis.newPotentialCoverage.size > 0 && (
                    <div className="mb-3">
                      <p className="text-sm text-gray-400 mb-2">
                        Potential Coverage (via Moves):
                        <span className="text-xs ml-2 text-gray-500">
                          *May require specific moves
                        </span>
                      </p>
                      <div className="flex flex-wrap gap-2 opacity-75">
                        {Array.from(analysis.newPotentialCoverage).map(type => (
                          <TypeBadge key={type} type={type} small />
                        ))}
                      </div>
                    </div>
                  )}

                  {/* Defensive Coverage */}
                  {analysis.newResistances.size > 0 && (
                    <div className="mb-3">
                      <p className="text-sm text-gray-400 mb-2">New Resistances:</p>
                      <div className="flex flex-wrap gap-2">
                        {Array.from(analysis.newResistances).map(type => (
                          <div key={type} className="flex items-center gap-1 bg-gray-600/50 rounded-lg px-2 py-1">
                            <TypeBadge type={type} small />
                            <span className="text-sm text-gray-300">½×</span>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {analysis.newImmunities.size > 0 && (
                    <div>
                      <p className="text-sm text-gray-400 mb-2">New Immunities:</p>
                      <div className="flex flex-wrap gap-2">
                        {Array.from(analysis.newImmunities).map(type => (
                          <div key={type} className="flex items-center gap-1 bg-gray-600/50 rounded-lg px-2 py-1">
                            <TypeBadge type={type} small />
                            <span className="text-sm text-gray-300">0×</span>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              )}

              {/* Shared Weaknesses Warning */}
              {analysis.sharedWeaknesses.length > 0 && (
                <div className="bg-gray-700 rounded-xl p-4">
                  <h3 className="text-lg font-semibold text-red-400 flex items-center gap-2 mb-3">
                    <Shield className="h-5 w-5" />
                    Shared Team Weaknesses
                  </h3>
                  <div className="flex flex-wrap gap-2">
                    {analysis.sharedWeaknesses.map(type => (
                      <TypeBadge key={type} type={type} small />
                    ))}
                  </div>
                </div>
              )}

              {/* Replacement Suggestions */}
              {team.length === 6 && analysis.replacementSuggestions.length > 0 && (
                <div className="bg-gray-700 rounded-xl p-4">
                  <h3 className="text-lg font-semibold text-blue-400 flex items-center gap-2 mb-3">
                    <ArrowRight className="h-5 w-5" />
                    Suggested Replacements
                  </h3>
                  <div className="space-y-3">
                    {analysis.replacementSuggestions.map(({ pokemon, reasons }) => (
                      <div key={pokemon.id} className="flex items-center justify-between bg-gray-600/50 rounded-lg p-3">
                        <div className="flex items-center gap-3">
                          <img
                            src={pokemon.sprites.front_default}
                            alt={pokemon.name}
                            className="w-12 h-12"
                          />
                          <div>
                            <p className="font-medium capitalize text-gray-100">
                              {pokemon.name}
                            </p>
                            <div className="flex gap-1 mt-1">
                              {pokemon.types.map(type => (
                                <TypeBadge key={type} type={type} small />
                              ))}
                            </div>
                            <p className="text-sm text-gray-400 mt-1">
                              {reasons.typeOverlap > 0 && 'Overlapping types • '}
                              {reasons.weaknessOverlap > 0 && 'Shared weaknesses • '}
                              {reasons.uniqueCoverage && 'Redundant coverage'}
                            </p>
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Add/Replace Button */}
              {/* <button
                onClick={handleAddPokemon}
                disabled={team.length === 6 && !analysis.replacementSuggestions.length}
                className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 
                         disabled:cursor-not-allowed text-white py-3 rounded-xl 
                         transition-colors font-medium"
              >
                {team.length < 6 
                  ? 'Add to Team' 
                  : analysis.replacementSuggestions.length > 0 
                    ? 'Replace Suggested Pokémon'
                    : 'Team is Full'}
              </button> */}
            </>
          )}
        </div>
      )}
    </div>
  );
};

export default PokemonTeamAnalyzer;
    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>src\components\TeamBuilder\TeamBuilder.jsx</file_path>
    <file_name>TeamBuilder.jsx</file_name>
    <content>
    <![CDATA[
import { Droppable } from 'react-beautiful-dnd';
import { Trash2 } from 'lucide-react';
import SearchInput from '../Shared/SearchInput';
import { PokemonCard } from './PokemonCard';
import EvolutionZone from './EvolutionZone';

const TeamBuilder = ({ 
  team, 
  setTeam,
  searchTerm,
  searchResults,
  loading,
  setSearchTerm,
  setSelectedPokemon,
  searchPokemon,
  setSearchResults
}) => {
  return (
    <div className="p-6">
      <div className="mb-6">
        <SearchInput
          value={searchTerm}
          onChange={(e) => {
            setSearchTerm(e.target.value);
            searchPokemon(e.target.value);
          }}
          loading={loading}
          searchResults={searchResults}
          onSelect={(pokemon) => {
            if (team.length < 6) {
              setTeam(prev => [...prev, {
                ...pokemon,
                types: pokemon.types.map(t => t.toLowerCase())
              }]);
              setSearchTerm('');
              setSearchResults([]);
            }
          }}
        />
      </div>

      <div className="flex flex-col gap-4">
        <Droppable droppableId="team" direction="horizontal">
          {(provided, snapshot) => (
            <div
              {...provided.droppableProps}
              ref={provided.innerRef}
              className={`grid grid-cols-2 sm:grid-cols-3 md:grid-cols-6 gap-4 min-h-[160px] ${
                snapshot.isDraggingOver ? 'bg-gray-700/50' : ''
              } rounded-lg p-2`}
            >
              {team.map((pokemon, index) => (
                <PokemonCard
                  key={pokemon.id}
                  pokemon={pokemon}
                  index={index}
                  onClick={setSelectedPokemon}
                />
              ))}
              {team.length < 6 && [...Array(6 - team.length)].map((_, i) => (
                <div
                  key={`empty-${i}`}
                  className="border-2 border-dashed border-gray-700 rounded-xl h-[160px] 
                           flex items-center justify-center bg-gray-800/50"
                >
                  <span className="text-gray-500">Empty Slot</span>
                </div>
              ))}
              {provided.placeholder}
            </div>
          )}
        </Droppable>

        {/* Action Zones */}
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
          {/* Evolution Zone */}
          <Droppable droppableId="evolution">
            {(provided, snapshot) => (
              <div
                {...provided.droppableProps}
                ref={provided.innerRef}
              >
                <EvolutionZone isDraggingOver={snapshot.isDraggingOver} />
                {provided.placeholder}
              </div>
            )}
          </Droppable>

          {/* Trash Zone */}
          <Droppable droppableId="trash">
            {(provided, snapshot) => (
              <div
                {...provided.droppableProps}
                ref={provided.innerRef}
                className={`flex items-center justify-center h-20 border-2 border-dashed 
                           rounded-xl transition-colors ${
                  snapshot.isDraggingOver 
                    ? 'border-red-500 bg-red-500/10' 
                    : 'border-gray-700 bg-gray-800/50'
                }`}
              >
                <div className="flex items-center gap-2 text-gray-400">
                  <Trash2 className={`w-6 h-6 ${
                    snapshot.isDraggingOver ? 'text-red-500' : 'text-gray-500'
                  }`} />
                  <span className={snapshot.isDraggingOver ? 'text-red-500' : ''}>
                    Drop here to remove Pokémon
                  </span>
                </div>
                {provided.placeholder}
              </div>
            )}
          </Droppable>
        </div>
      </div>
    </div>
  );
};

export default TeamBuilder;
    ]]>
    </content>
  </file_entry>

  <file_entry>
    <file_path>src\components\TeamBuilder\TeamRecommendations.jsx</file_path>
    <file_name>TeamRecommendations.jsx</file_name>
    <content>
    <![CDATA[
import React, { useMemo } from 'react';
import TypeBadge from '../Shared/TypeBadge';
import { Shield, Swords, Zap, Target } from 'lucide-react';

const TeamRecommendations = ({ team, TypeChart }) => {
  const analysis = useMemo(() => {
    // Track STAB coverage separately from potential coverage
    const stabCoverage = new Set();
    const potentialCoverage = new Set();
    const weaknesses = new Set();
    const resistances = new Set();
    
    // Track team stats distribution
    const statsDistribution = {
      hp: 0,
      attack: 0,
      defense: 0,
      'special-attack': 0,
      'special-defense': 0,
      speed: 0
    };
    
    // Analyze each Pokémon
    team.forEach(pokemon => {
      // Calculate STAB coverage from this Pokemon's types
      pokemon.types.forEach(attackingType => {
        if (TypeChart[attackingType]) {
          // Add STAB coverage
          TypeChart[attackingType].strengths.forEach(defendingType => {
            stabCoverage.add(defendingType);
          });

          // Track defensive matchups
          Object.entries(TypeChart).forEach(([type, info]) => {
            // Check if this type is super effective against our type
            if (info.strengths.includes(attackingType)) {
              weaknesses.add(type);
            }
            // Check if our type resists this type
            if (TypeChart[attackingType].resistances.includes(type)) {
              resistances.add(type);
            }
            // Check if our type is immune to this type
            if (TypeChart[attackingType].immunities.includes(type)) {
              resistances.add(type); // Add immunities to resistances for recommendation purposes
            }
          });
        }
      });

      // Add potential coverage from moves if available
      if (pokemon.moves) {
        pokemon.moves.forEach(move => {
          if (TypeChart[move.type] && !pokemon.types.includes(move.type)) {
            TypeChart[move.type].strengths.forEach(t => potentialCoverage.add(t));
          }
        });
      }

      // Add to stats distribution
      pokemon.stats.forEach((stat, index) => {
        const statName = ['hp', 'attack', 'defense', 'special-attack', 'special-defense', 'speed'][index];
        statsDistribution[statName] += stat.base_stat;
      });
    });

    // Find missing type coverage (compared to all possible types)
    const allTypes = Object.keys(TypeChart);
    const missingCoverage = allTypes.filter(type => 
      !stabCoverage.has(type) && !potentialCoverage.has(type)
    );

    // Find common weaknesses (types that multiple Pokémon are weak to)
    const commonWeaknesses = Array.from(weaknesses).filter(type => {
      const vulnerablePokemon = team.filter(p => 
        p.types.some(t => {
          // Pokemon is vulnerable if the attacking type is super effective
          // AND the Pokemon's type doesn't resist or isn't immune to it
          return TypeChart[type]?.strengths.includes(t) &&
                 !TypeChart[t]?.resistances.includes(type) &&
                 !TypeChart[t]?.immunities.includes(type);
        })
      );
      return vulnerablePokemon.length >= 2;
    });

    // Calculate recommended types with detailed scoring
    const recommendedTypes = allTypes
      .map(type => {
        if (team.some(p => p.types.includes(type))) return null; // Skip types we already have
        
        let score = 0;
        const newCoverage = new Set();
        const newResistances = new Set();
        
        // Check new coverage this type would bring
        if (TypeChart[type]) {
          TypeChart[type].strengths.forEach(strength => {
            if (!stabCoverage.has(strength) && !potentialCoverage.has(strength)) {
              score += 3;
              newCoverage.add(strength);
            }
          });
        }

        // Check new resistances and immunities this type would bring
        const defensiveContributions = new Set([
          ...TypeChart[type].resistances,
          ...TypeChart[type].immunities
        ]);
        
        defensiveContributions.forEach(defType => {
          if (!resistances.has(defType)) {
            score += 4;
            newResistances.add(defType);
          }
        });
        
        // Additional score for covering team weaknesses
        commonWeaknesses.forEach(weakness => {
          if ((TypeChart[type].resistances.includes(weakness) || 
               TypeChart[type].immunities.includes(weakness)) &&
              !resistances.has(weakness)) {
            score += 2;
          }
        });

        return score >= 3 ? {
          type,
          score,
          coverageCount: newCoverage.size,
          resistanceCount: newResistances.size
        } : null;
      })
      .filter(Boolean) // Remove null entries
      .sort((a, b) => b.score - a.score); // Sort by score descending

    // Analyze stat distribution
    const avgStats = Object.entries(statsDistribution).map(([stat, total]) => ({
      stat,
      average: total / (team.length || 1)
    }));

    const weakestStats = avgStats
      .sort((a, b) => a.average - b.average)
      .slice(0, 2);

    // Identify role gaps
    const roles = {
      wallBreaker: team.some(p => p.stats[1].base_stat > 100 || p.stats[3].base_stat > 100),
      tank: team.some(p => p.stats[0].base_stat > 100 && p.stats[2].base_stat > 90),
      speedControl: team.some(p => p.stats[5].base_stat > 100),
      specialWall: team.some(p => p.stats[4].base_stat > 100),
      physicalWall: team.some(p => p.stats[2].base_stat > 100)
    };

    return {
      stabCoverage: Array.from(stabCoverage),
      potentialCoverage: Array.from(potentialCoverage),
      missingCoverage,
      commonWeaknesses,
      weakestStats,
      roles,
      resistances: Array.from(resistances),
      recommendedTypes
    };
  }, [team, TypeChart]);

  const getRoleRecommendations = () => {
    const missing = [];
    if (!analysis.roles.wallBreaker) missing.push("Wall Breaker (high Attack/Sp.Attack)");
    if (!analysis.roles.tank) missing.push("Bulk Tank (high HP/Defense)");
    if (!analysis.roles.speedControl) missing.push("Speed Control (high Speed)");
    if (!analysis.roles.specialWall) missing.push("Special Wall (high Sp.Defense)");
    if (!analysis.roles.physicalWall) missing.push("Physical Wall (high Defense)");
    return missing;
  };

  return (
    <div className="space-y-6 bg-gray-800 rounded-xl p-6">
      <h2 className="text-xl font-bold text-white mb-4">Team Analysis</h2>

      {/* Recommended Types - New Section */}
      {analysis.recommendedTypes.length > 0 && (
        <div className="space-y-2">
          <h3 className="text-lg font-semibold text-gray-100 flex items-center gap-2">
            <Target size={20} />
            Recommended Types
          </h3>
          <div className="bg-gray-700/50 rounded-lg p-3">
            <p className="text-sm text-gray-400 mb-2">
              Types ranked by new coverage (C) and resistances (R):
            </p>
            <div className="flex flex-wrap gap-2">
              {analysis.recommendedTypes.map(({ type, coverageCount, resistanceCount }) => (
                <div key={type} className="flex items-center gap-2 bg-gray-600/50 rounded-lg px-2 py-1">
                  <TypeBadge type={type} small />
                  <span className="text-sm text-gray-400">
                    {coverageCount > 0 && `C:${coverageCount}`}
                    {coverageCount > 0 && resistanceCount > 0 && ' '}
                    {resistanceCount > 0 && `R:${resistanceCount}`}
                  </span>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Type Coverage */}
      <div className="space-y-2">
        <h3 className="text-lg font-semibold text-gray-100">Type Coverage</h3>
        
        {/* STAB Coverage */}
        <div className="bg-gray-700/50 rounded-lg p-3">
          <p className="text-sm text-gray-400 mb-2">Guaranteed Coverage (STAB):</p>
          {analysis.stabCoverage.length > 0 ? (
            <div className="flex flex-wrap gap-2">
              {analysis.stabCoverage.map(type => (
                <TypeBadge key={type} type={type} small />
              ))}
            </div>
          ) : (
            <p className="text-gray-500 text-sm">No STAB coverage yet</p>
          )}
        </div>

        {/* Potential Coverage */}
        {analysis.potentialCoverage.length > 0 && (
          <div className="bg-gray-700/50 rounded-lg p-3">
            <p className="text-sm text-gray-400 mb-2">
              Potential Coverage (via Moves):
              <span className="text-xs ml-2 text-gray-500">
                *May require specific moves
              </span>
            </p>
            <div className="flex flex-wrap gap-2 opacity-75">
              {analysis.potentialCoverage.map(type => (
                <TypeBadge key={type} type={type} small />
              ))}
            </div>
          </div>
        )}
      </div>

      {/* Missing Coverage */}
      {analysis.missingCoverage.length > 0 && (
        <div className="space-y-2">
          <h3 className="text-lg font-semibold text-gray-100">Missing Coverage</h3>
          <div className="flex flex-wrap gap-2">
            {analysis.missingCoverage.map(type => (
              <TypeBadge key={type} type={type} />
            ))}
          </div>
        </div>
      )}

      {/* Common Weaknesses */}
      {analysis.commonWeaknesses.length > 0 && (
        <div className="space-y-2">
          <h3 className="text-lg font-semibold text-gray-100">Team Vulnerabilities</h3>
          <p className="text-gray-400 text-sm mb-2">
            Multiple Pokémon are weak to these types:
          </p>
          <div className="flex flex-wrap gap-2">
            {analysis.commonWeaknesses.map(type => (
              <TypeBadge key={type} type={type} />
            ))}
          </div>
        </div>
      )}

      {/* Role Gaps */}
      {getRoleRecommendations().length > 0 && (
        <div className="space-y-2">
          <h3 className="text-lg font-semibold text-gray-100">Missing Roles</h3>
          <ul className="list-disc list-inside text-gray-300 space-y-1">
            {getRoleRecommendations().map(role => (
              <li key={role}>{role}</li>
            ))}
          </ul>
        </div>
      )}

      {/* Stat Distribution */}
      {analysis.weakestStats.length > 0 && (
        <div className="space-y-2">
          <h3 className="text-lg font-semibold text-gray-100">Team Stats</h3>
          <p className="text-gray-400 text-sm">Consider adding Pokémon with high:</p>
          <ul className="list-disc list-inside text-gray-300">
            {analysis.weakestStats.map(({stat}) => (
              <li key={stat} className="capitalize">
                {stat.replace('-', ' ')}
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
};

export default TeamRecommendations;
    ]]>
    </content>
  </file_entry>
</jsx_files>
